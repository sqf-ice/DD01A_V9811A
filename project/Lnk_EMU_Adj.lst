C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LNK_EMU_ADJ
OBJECT MODULE PLACED IN .\Lnk_EMU_Adj.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\C_Source\S1_HardDrv\V9811A_EMU\Lnk_EMU_Adj.c LARGE BROWSE INCDIR(..\C_So
                    -urce\S0_System;..\C_Source\S1_HardDrv;..\C_Source\S2_MyLib;..\C_Source\S3_ApiPlat;..\C_Source\S4_ApiUser;..\C_Source\S5_
                    -ApiProtocol;..\C_Source\S6_MyIncludes;..\C_Source\S1_HardDrv\V9811A_EMU;..\C_Source\S1_HardDrv\V9811A_MCU;..\C_Source\S1
                    -_HardDrv\E2P_24CXXX) DEBUG OBJECTEXTEND PRINT(.\Lnk_EMU_Adj.lst) OBJECT(.\Lnk_EMU_Adj.obj)

line level    source

   1          /*
   2          *****************Copyright (c)*************************************
   3          **      Hangzhou Xili Watthour Meter Manufacture Co., Ltd. 
   4          **--------------file info--------------------------------------------
   5          **name                  : Lnk_EMU_Adj.c
   6          **Author                : maji
   7          **date                  : 2016-04-20 
   8          **description   : G80F92XDµÄEMU¼ÆÁ¿Ä£¿éÁ´Â·²ãÐ£±í´¦ÀíC´úÂë
   9          **note                  : MCU- G80F92XD £¬MERTER FOR DL06A
  10          **--------------------Version History -------------------------------------
  11          ** NO. Date         Ver      By         Description 
  12          **==============================================================
  13          ** 1   2016-04-20   v01.00   sosomj     1. frist version                             
  14          **
  15          **==============================================================
  16          */
  17          
  18          #include <MyIncludes_H.h>
  19          
  20          
  21          
  22          ST_EMU_ADJ_PARAM  gs_adj_emu_param;
  23          ST_EMU_ADJ_VAR      gs_emu_adj_var;
  24          
  25          
  26          /*********************************************************************************************************
  27          **  Ð£±íÏà¹Ø²ÎÊý³õÊ¼»¯Ä¬ÈÏÊý¾Ý
  28          ********************************************************************************************************/
  29          const  ST_EMU_ADJ_PARAM   code   default_adj_emu_param_tab = 
  30          {
  31              0,  //uint32 w1gain;         //Í¨µÀ1¹¦ÂÊÔöÒæ¼Ä´æÆ÷(ÓÐ¹¦ÎÞ¹¦Ê¹ÓÃÍ¬Ò»×é)  //0xFF,0x3B,0x66,0x28,
  32              0,  //uint32 p1cal;           //Í¨µÀ1µçÑ¹µçÁ÷ÏàÎ»²¹³¥¼Ä´æÆ÷  //
  33              0,  //uint32 watt1os;      //Í¨µÀ1ÓÐ¹¦¹¦ÂÊÆ«ÖÃ  //
  34              0,  //uint32 irms1os;      //Í¨µÀ1µçÁ÷ÓÐÐ§ÖµÆ«ÖÃ  //
  35              0,  //uint32 w2gain;         //Í¨µÀ2¹¦ÂÊÔöÒæ¼Ä´æÆ÷(ÓÐ¹¦ÎÞ¹¦Ê¹ÓÃÍ¬Ò»×é)  //0xFF3B6628
  36              0,  //uint32 p2cal;           //Í¨µÀ2µçÑ¹µçÁ÷ÏàÎ»²¹³¥¼Ä´æÆ÷  //
  37              0,  //uint32 watt2os;      //Í¨µÀ2ÓÐ¹¦¹¦ÂÊÆ«ÖÃ  //
  38              0,  //uint32 irms2os;      //Í¨µÀ2µçÁ÷ÓÐÐ§ÖµÆ«ÖÃ  //
  39                  0,  //uint32 urmsos       //µçÑ¹ÓÐÐ§ÖµÆ«ÖÃ  //
  40              0.075138056,  //uint32 vconst_val_ch1;   //Í¨µÀ1µôÁãÏßµçÑ¹¹Ì¶¨Öµ //    
  41              0.112707084,  //uint32 vconst_val_ch2;   //Í¨µÀ2µôÁãÏßµçÑ¹¹Ì¶¨Öµ //
  42              1.07355e-005,  //float vrms_xs;          //ÈËÎª¼ÆËãµÄµçÑ¹ÓÐÐ§ÖµÏµÊý  //9.19946e-006
  43              //2019-01-17ÐÞ¸ÄµçÁ÷ÓÐÐ§ÖµÏµÊý
  44                  0.000163094,//0.000153309,  //float i1rms_xs;         //ÈËÎª¼ÆËãµÄÍ¨µÀ1µçÁ÷ÓÐÐ§ÖµÏµÊý  //
  45              0.000163094,//0.000153309,  //float i2rms_xs;         //ÈËÎª¼ÆËãµÄÍ¨µÀ2µçÁ÷ÓÐÐ§ÖµÏµÊý  //8.279879e-005
             -   1.14993e-007
  46              0,  //uint16     csck;  //Ð£ÑéºÍ //
  47          };
  48          
  49          const  ST_Adjust_CONST  code   cst_adj_const = 
  50          {
  51              C_Un*10,        //uint32 U_ref;       //²Î±ÈµçÑ¹Öµ£¬Á¿¸Ù0.1V  // 
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 2   

  52              C_Ib*1000,     //uint32 I_ref;       //²Î±ÈµçÁ÷Öµ£¬Á¿¸Ù0.001A  //     
  53              INITGATEP,     //uint32 GATEP;       // ¼ÆÁ¿ÃÅÏÞÖµ //
  54              INITGATECP,   //uint32 C_GATECP;     // Ç±¶¯ÃÅÏÞÖµ //
  55              REF_RMSPn,    // uint32 C_PCONST;    // ¶î¶¨¹¦ÂÊµÄÐ£×¼ºó±ê×¼Öµ//
  56              K_RMSP,         //float   Kim_Prms;  //ÓÐ¹¦¹¦ÂÊÓÐÐ§ÖµÏµÊý//  
  57              K_RMSP2,            // ÎÞ¹¦¹¦ÂÊÓÐÐ§ÖµÏµÊý
  58          };
  59          
  60          
  61          const  EMU_CK_TAB  code   cst_emu_selfchck_tab[] = 
  62          {
  63              &gs_adj_emu_param.w1gain,            SCP,    //Í¨µÀ1¹¦ÂÊÔöÒæ¼Ä´æÆ÷(ÓÐ¹¦ÎÞ¹¦Ê¹ÓÃÍ¬Ò»×é)  //
  64              &gs_adj_emu_param.w2gain,            SCQ,    //Í¨µÀ2¹¦ÂÊÔöÒæ¼Ä´æÆ÷(ÓÐ¹¦ÎÞ¹¦Ê¹ÓÃÍ¬Ò»×é)  //
  65              &gs_adj_emu_param.p1cal,            PHCCtrl1,    //Í¨µÀ1µçÑ¹µçÁ÷ÏàÎ»²¹³¥¼Ä´æÆ÷  //
  66              &gs_adj_emu_param.p2cal,            PHCCtrl2,    //Í¨µÀ2µçÑ¹µçÁ÷ÏàÎ»²¹³¥¼Ä´æÆ÷  //
  67              &gs_adj_emu_param.watt1os,            PARAPC,    //Í¨µÀ1ÓÐ¹¦¹¦ÂÊÆ«ÖÃ  // 
  68              &gs_adj_emu_param.watt2os,            PARAQC,    //Í¨µÀ2ÓÐ¹¦¹¦ÂÊÆ«ÖÃ  //
  69                  &gs_adj_emu_param.irms1os,                        SCI1,  //Í¨µÀ1µçÁ÷ÓÐÐ§ÖµÆ«ÖÃ  // 
  70                  &gs_adj_emu_param.irms2os,                        SCI2,  //Í¨µÀ1µçÁ÷ÓÐÐ§ÖµÆ«ÖÃ    // 
  71                  &gs_adj_emu_param.urmsos,                         SCU,   //µçÑ¹ÓÐÐ§ÖµÆ«ÖÃ  //
  72          };
  73          
  74          
  75          const  EMU_CONST_CK_TAB  code   cst_emu_constchck_tab[] = 
  76          {
  77              INITGATECP,           GATECP,    //uint32 C_GATECP;   // Ç±¶¯ÃÅÏÞÖµ //
  78              INITGATECQ,           GATECQ,    //uint32 C_GATECP;   // Ç±¶¯ÃÅÏÞÖµ //
  79          };
  80          
  81          
  82          //9260F ¹Ì¶¨±í²ÎÊý//
  83          const  EMU_CONST_CK_TAB_9260F code   cst_emu_constchck_tab_9260f[] = 
  84          {
  85              0x1D0004C3,          RegANCtrl0,    //0x185  BIT0-BIT1 IÔöÒæ 00 x32 01 x16 10 x8  11 x1
  86                  0x30000000,          RegANCtrl1,    //0x185 ÔöÒæI:32£¬U:1£¬M:4 ÎÂ¶ÈÏµÊý£¬È«¾ÖµçÁ÷Æ«ÖÃ
  87              0x00000000,          RegANCtrl2,     //0x187  
  88              0x811D2BA7,          RegBPFPARA,    //0x0125 ´øÍ¨ÂË²¨Æ÷ÏµÊý 0x811D2BA7
  89              0x00000000,          RegMTPARA0,    //0x183 CF¹¤×÷Ê±ÖÓ3.2MHz Ê¹ÄÜCFÊä³ö£¬ÄÜÁ¿ÀÛ¼Ó£¬Æð¶¯Ç±¶¯£¬ÄÜÁ¿À´Ô´£
             -ºÆ½¾ùÈ«²¨ÓÐ¹¦
  90              0,                   RegWARTU,     // U32  µçÑ¹ÓÐÐ§Öµ±È²îÐ£ÕýÖµ //
  91              0,                   RegWARTI,     // U32  I1 µçÁ÷ÓÐÐ§Öµ±È²îÐ£ÕýÖµ//
  92          };
  93          
  94          /*********************************************************************************************************
  95          ** º¯ÊýÃû³Æ: Save_EMU_AdjParam
  96          ** ¹¦ÄÜÃèÊö: EMUÏà¹Ø²ÎÊýÐÞ¸ÄºóµÄ±£´æ¸üÐÂ´¦Àí
  97          ** Èë¿Ú²ÎÊý: ÎÞ
  98          ** ³ö¿Ú²ÎÊý: ÎÞ
  99          ********************************************************************************************************/
 100          void Save_EMU_AdjParam(void)
 101          {
 102   1          gs_adj_emu_param.csck =Lib_get_csck_int16u_num((uint8 *)&gs_adj_emu_param.w1gain,(LEN_BLOCK70_EMU_PARA
             -M_E2P-2),CHECKWORD);
 103   1          mem_db_write(ADR_BLOCK70_EMU_PARAM_E2P, (uint8 *)&gs_adj_emu_param.w1gain,(LEN_BLOCK70_EMU_PARAM_E2P-2
             -),MEM_E2P1); 
 104   1      }
 105          
 106          
 107          
 108          /*********************************************************************************************************
 109          ** º¯ÊýÃû³Æ: Save_EMU_AdjParam
 110          ** ¹¦ÄÜÃèÊö: EMUÏà¹Ø²ÎÊýÐÞ¸ÄºóµÄ±£´æ¸üÐÂ´¦Àí
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 3   

 111          ** Èë¿Ú²ÎÊý: ÎÞ
 112          ** ³ö¿Ú²ÎÊý: ÎÞ
 113          ********************************************************************************************************/
 114          void Get_EMU_AdjParam(void)
 115          {
 116   1         uint16  csck_u16;
 117   1      
 118   1          //RAM Êý¾Ý¼ì²é  //
 119   1          csck_u16 =Lib_get_csck_int16u_num((uint8 *)&gs_adj_emu_param.w1gain,(LEN_BLOCK70_EMU_PARAM_E2P-2),CHEC
             -KWORD);
 120   1          if(csck_u16 != gs_adj_emu_param.csck)
 121   1          {
 122   2              mem_read((uint8 *)&gs_adj_emu_param.w1gain, ADR_BLOCK70_EMU_PARAM_E2P, LEN_BLOCK70_EMU_PARAM_E2P, 
             -MEM_E2P1);
 123   2          }
 124   1      }
 125          
 126          
 127          /*********************************************************************************************************
 128          ** º¯ÊýÃû³Æ: Check_EMU_AdjParam
 129          ** ¹¦ÄÜÃèÊö: EMU¼Ä´æÆ÷Ð£Ñé
 130          ** Èë¿Ú²ÎÊý: ÎÞ
 131          ** ³ö¿Ú²ÎÊý: ÎÞ
 132          ********************************************************************************************************/
 133          void Check_EMU_AdjParam(void)
 134          {
 135   1         ST_U32_U08 regval;
 136   1         uint8 i;
 137   1         EMU_CK_TAB tmp_tab;
 138   1         EMU_CONST_CK_TAB  tmp_const_tab;
 139   1         uint32 ucSum=0;
 140   1         uint8  u8_tmp;
 141   1      
 142   1          // ¼ì²éRAMÄÚµÄÐ£±í²ÎÊýÊý¾Ý£¬Èç¹ûÐ£Ñé²»ÕýÈ·Ôò´ÓEEPROMÄÚ»ñÈ¡ //
 143   1          Get_EMU_AdjParam();   
 144   1      
 145   1              ///¶Á³ö³£Êý±¶Æµ±êÖ¾£¬ÒÔ±ã¸ø³öÕýÈ·µÄÃÅÏÞÖµ yang 2017-12-28///
 146   1              mem_read(&u8_tmp, ADR_METER_PARAM1_CONST_FAST_FLG, 1, MEM_E2P1);        
 147   1              if(u8_tmp==0x3C)
 148   1              {
 149   2                                //±¶Æµ10±¶  //
 150   2                      SetMeterCfgACK(INITGATEP_10M,GATEP);            //ÉèÖÃI1Í¨µÀ¹¦ÂÊÃÅÏÞÖÆ
 151   2                      SetMeterCfgACK(INITGATEP_10M,GATEQ);            //ÉèÖÃI2Í¨µÀ¹¦ÂÊÃÅÏÞÖÆ                          
 152   2              }
 153   1              else
 154   1              {
 155   2                      SetMeterCfgACK(INITGATEP,GATEP);                //ÉèÖÃI1Í¨µÀ¹¦ÂÊÃÅÏÞÖÆ
 156   2                      SetMeterCfgACK(INITGATEP,GATEQ);                //ÉèÖÃI2Í¨µÀ¹¦ÂÊÃÅÏÞÖÆ 
 157   2              }
 158   1      
 159   1      
 160   1          // ¹Ì¶¨ÖµÅäÖÃµÄÐ£±íÏà¹ØÊý¾Ý¼ì²é //    
 161   1          for(i=0;i<(dim(cst_emu_constchck_tab));i++)
 162   1          {
 163   2              tmp_const_tab.emuAdr = cst_emu_constchck_tab[i].emuAdr;
 164   2              tmp_const_tab.val = cst_emu_constchck_tab[i].val;
 165   2              regval.u32 = 0;
 166   2              regval.u32 = ReadMeterParaACK(tmp_const_tab.emuAdr);     //¼ÆÁ¿ÃÅÏÞÖµ¼ì²é  //
 167   2              if(regval.u32 != tmp_const_tab.val)
 168   2              {
 169   3                  regval.u32 = tmp_const_tab.val;
 170   3                  SetMeterCfgACK(regval.u32,tmp_const_tab.emuAdr);
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 4   

 171   3              }  
 172   2          }
 173   1          // ¶ÁÈ¡´æ´¢Ð¾Æ¬ÄÚµÄÐ£±íÊý¾Ý½øÐÐ¼ì²é //
 174   1          for(i=0;i<(dim(cst_emu_selfchck_tab));i++)
 175   1          {
 176   2              tmp_tab.emuAdr = cst_emu_selfchck_tab[i].emuAdr;
 177   2              tmp_tab.ramAdr = cst_emu_selfchck_tab[i].ramAdr;
 178   2              regval.u32 = 0;
 179   2              regval.u32= ReadMeterParaACK(tmp_tab.emuAdr);
 180   2              if((tmp_tab.emuAdr==PHCCtrl1)||(tmp_tab.emuAdr==PHCCtrl2))
 181   2              {
 182   3                  if(regval.B08[3] != (uint8)(*tmp_tab.ramAdr))
 183   3                  {
 184   4                      regval.u32 = (uint8)(*tmp_tab.ramAdr);
 185   4                      SetMeterCfgACK(regval.u32,tmp_tab.emuAdr);
 186   4                  }      
 187   3              }
 188   2              else
 189   2              {
 190   3                  if(regval.u32 != *tmp_tab.ramAdr)
 191   3                  {
 192   4                      regval.u32 = *tmp_tab.ramAdr;
 193   4                      SetMeterCfgACK(regval.u32,tmp_tab.emuAdr);
 194   4                  }
 195   3              }    
 196   2           }
 197   1      
 198   1      }
 199          
 200          /*********************************************************************************************************
 201          ** º¯ÊýÃû³Æ: Get_Original_Power
 202          ** ¹¦ÄÜÃèÊö: »ñÈ¡Ô­Ê¼¹¦ÂÊÖµ
 203          ** Èë¿Ú²ÎÊý: avr_times-Æ½¾ù´ÎÊý 
 204          ** ³ö¿Ú²ÎÊý: ÎÞ         
 205          ********************************************************************************************************/
 206          uint32 Get_Original_Power(uint8 avr_times,uint8 ch)
 207          {
 208   1          uint32 val;
 209   1          uint8  i;
 210   1          uint32 aery_old;
 211   1          uint32 aery_val;
 212   1          uint32 avr_aery;
 213   1          ST_U32_U08 TempValue;
 214   1          CLRWDT();
 215   1      
 216   1          avr_aery=0;
 217   1          gs_emu_adj_var.sec_flg=FALSE; 
 218   1          for (i=0;i<avr_times;i++)
 219   1          {
 220   2              CLRWDT();
 221   2              while(gs_emu_adj_var.sec_flg==FALSE);
 222   2              gs_emu_adj_var.sec_flg=FALSE; 
 223   2              CLRWDT(); 
 224   2              if(ch==EMU_CH_L)
 225   2              {
 226   3                  val=ReadMeterParaACK(DATAIQ);         //DATAP 2017-1-12 ZWK
 227   3              }
 228   2              else
 229   2              {
 230   3                 // val=ReadMeterParaACK(DATAIQ);  // RegIAP È«²¨¹¦ÂÊË²Ê±Öµ
 231   3                 if(ReadRaccoon(RegIAP,1,BPhy)==TRUE)   //RegAAP 2017-1-12 ZWK   // ×î´ó 200ms¶ÁÈ¡µÈ´ý    //  ÀíÂÛÊ±¼ä7
             -6ms
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 5   

 232   3                 {
 233   4                      memcpy((uint8*)TempValue.B08,gs_RacCtrl.ucBuf+3,4); //ÓÐ¹¦ÃëÆ½¾ù¹¦ÂÊ
 234   4                      Lib_Rev_Copy_Arry(&TempValue.B08[0],4);// µÍ×Ö½ÚÔÚÇ°  µ¹ÖÃ//
 235   4                      val = TempValue.u32;
 236   4                 }
 237   3                 else // ¶ÁÈ¡Ê§°Ü£¬ 
 238   3                 {
 239   4                      gs_sys_run.font_fg |= BIT4_FONT_FG_EnyBottom;
 240   4                 }
 241   3              }
 242   2      
 243   2             if(val>=0x80000000)
 244   2             {
 245   3                val=~val+1;  
 246   3             }
 247   2      
 248   2             aery_old=val;
 249   2             avr_aery=avr_aery+aery_old;
 250   2          }   
 251   1      
 252   1          aery_val=avr_aery/avr_times;
 253   1          CLRWDT();
 254   1          NOP();
 255   1          return(aery_val);
 256   1      }               
 257          
 258          
 259          
 260          /*********************************************************************************************************
 261          ** º¯ÊýÃû³Æ: Get_Original_Irms
 262          ** ¹¦ÄÜÃèÊö: »ñÈ¡Ô­Ê¼µçÁ÷ÓÐÐ§ÖµÊý¾Ý
 263          ** Èë¿Ú²ÎÊý: avr_times-Æ½¾ù´ÎÊý 
 264          ** ³ö¿Ú²ÎÊý: ÎÞ         
 265          ********************************************************************************************************/
 266          uint32 Get_Original_Irms(uint8 avr_times,uint8 ch)
 267          {
 268   1          uint32 val;
 269   1          uint8  i;
 270   1          uint32 aery_old;
 271   1          uint32 aery_val;
 272   1          uint32 avr_aery;
 273   1          ST_U32_U08 TempValue;
 274   1          CLRWDT();
 275   1      
 276   1          avr_aery=0;
 277   1          gs_emu_adj_var.sec_flg=FALSE; 
 278   1          for (i=0;i<avr_times;i++)
 279   1          {
 280   2              CLRWDT();
 281   2              while(gs_emu_adj_var.sec_flg==FALSE);
 282   2              gs_emu_adj_var.sec_flg=FALSE; 
 283   2              CLRWDT(); 
 284   2              if(ch==EMU_CH_L)
 285   2              {
 286   3                  val=ReadMeterParaACK(RMSII1);        
 287   3              }
 288   2              else
 289   2              {
 290   3                 // val=ReadMeterParaACK(DATAIQ); //RegIAP È«²¨µçÁ÷Ë²Ê±Öµ
 291   3                 if(ReadRaccoon(RegARTI,1,BPhy)==TRUE)     // ×î´ó 200ms¶ÁÈ¡µÈ´ý    //  ÀíÂÛÊ±¼ä15ms
 292   3                 {
 293   4                      memcpy((uint8*)TempValue.B08,gs_RacCtrl.ucBuf+3,4); //ÓÐ¹¦ÃëÆ½¾ù¹¦ÂÊ
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 6   

 294   4                      Lib_Rev_Copy_Arry(&TempValue.B08[0],4);// µÍ×Ö½ÚÔÚÇ°  µ¹ÖÃ//
 295   4                     val = TempValue.u32;
 296   4                 }
 297   3                 else // ¶ÁÈ¡Ê§°Ü£¬ ÖØÐÂ¶ÁÈ¡Ò»´Î// 
 298   3                 {
 299   4                      gs_sys_run.font_fg |= BIT4_FONT_FG_EnyBottom;
 300   4                 }
 301   3              }
 302   2      
 303   2             if(val>=0x80000000)
 304   2             {
 305   3                val=~val+1;  
 306   3             }
 307   2      
 308   2             aery_old=val;
 309   2             avr_aery=avr_aery+aery_old;
 310   2          }   
 311   1      
 312   1          aery_val=avr_aery/avr_times;
 313   1          CLRWDT();
 314   1          NOP();
 315   1          return(aery_val);
 316   1      }        
 317          
 318          
 319          /*=========================================================================================\n
 320          * @function_name: CalculateSC
 321          * @function_file: EnergyBottom.c
 322          * @ÃèÊö: ±È²î¼ÆËã¹«Ê½
 323          * 
 324          * 
 325          * @²ÎÊý: 
 326          * @param:CurValue  :µç±íÓÐ¹¦¹¦ÂÊÖµ
 327          * @param:TarValue  :±ê×¼±íÓÐ¹¦¹¦ÂÊÖµ
 328          * 
 329          * @·µ»Ø: 
 330          * @return: uint32 
 331          * @×÷Õß:   lwb (2012-03-08)
 332          * @±¸×¢: 
 333          *-------------------------------------------------------------------------------------------
 334          * @ÐÞ¸ÄÈË:  
 335          * @ÐÞ¸ÄÄÚÈÝ: 
 336          ===========================================================================================*/
 337          INT32U CalculateSC(INT32U CurValue,INT32U TarValue)
 338          {
 339   1          //  2016-5-20  mj //                
 340   1          INT32S s32_tmp0;
 341   1          double f_CurValue,f_TarValue,f_Error;
 342   1          double f_s32_tmp0,f_s32_tmp1,f_s32_tmp2,f_s32_tmp3;
 343   1      
 344   1          // »ñÈ¡µ±Ç°Îó²î  ((CurValue-TarValue)/TarValue )*100% //    
 345   1          f_CurValue = (double)CurValue;
 346   1          f_TarValue = (double)TarValue;
 347   1          f_Error = (f_CurValue-TarValue)*1.0/f_TarValue;
 348   1      
 349   1              f_s32_tmp0 = 1.0/(1+f_Error);
 350   1      
 351   1              f_s32_tmp1 = f_s32_tmp0 - 1.0;
 352   1              
 353   1              f_s32_tmp2 = f_s32_tmp1* 0x80000000;
 354   1              
 355   1              f_s32_tmp3 = floor(f_s32_tmp2);     // ÏòÏÂÈ¡Õû //
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 7   

 356   1              s32_tmp0 = (INT32S)f_s32_tmp3;  
 357   1              return (s32_tmp0);
 358   1      }
 359          
 360          /*=========================================================================================\n
 361          * @function_name: CalculateAC
 362          * @function_file: EnergyBottom.c
 363          * @ÃèÊö: ½Ç²î¼ÆËã¹«Ê½
 364          * 
 365          * 
 366          * @²ÎÊý: 
 367          * @param:CurValue   £ºµç±í¹¦ÂÊ 
 368          * @param:TarValue   £º±ê×¼±í¹¦ÂÊ
 369          * 
 370          * @·µ»Ø: 
 371          * @return: uint8    
 372          * @×÷Õß:   lwb (2012-06-18)
 373          * @±¸×¢: 
 374          *-------------------------------------------------------------------------------------------
 375          * @ÐÞ¸ÄÈË:  
 376          * @ÐÞ¸ÄÄÚÈÝ: 
 377          ===========================================================================================*/
 378          INT8U CalculateAC(INT32U CurValue,INT32U TarValue)
 379          {
 380   1          //¼ÆËã¹«Ê½¸ü»»,À×ÎÄ±ó£¬2011Äê7ÔÂ14ÈÕ//
 381   1          INT16U Error;                    
 382   1          INT8U Result;
 383   1              INT8U JCFH;
 384   1              
 385   1              JCFH = 0;
 386   1              if(TarValue < 50)   return 0;
 387   1              
 388   1              if(TarValue>CurValue)  
 389   1              {
 390   2                      // ¸ºÎó²î //
 391   2                      Error=(TarValue-CurValue)*1000/TarValue;            //¼ÆËãÎó²îÖµ¡£¡£À©´ó1000
 392   2                      JCFH = 1;
 393   2              }
 394   1              else
 395   1              {
 396   2                      // ÕýÎó²î //
 397   2                      Error=(CurValue-TarValue)*1000/TarValue;            //¼ÆËãÎó²îÖµ¡£¡£À©´ó1000
 398   2              }
 399   1          Result = (INT32U)3011*Error/2000;
 400   1              if(JCFH==1)
 401   1              {
 402   2                      Result|=BIT7;
 403   2              }
 404   1          return Result; 
 405   1      }
 406          
 407          /*********************************************************************************************************
 408          ** º¯ÊýÃû³Æ: SoftAdjust_IB_Process
 409          ** ¹¦ÄÜÃèÊö: Ð£×¼´ó¹¦ÂÊ
 410          ** Èë¿Ú²ÎÊý: jzval£ºÀíÂÛ¹¦ÂÊÖµ£ºÂö³å³£Êý/3600*±íÌ¨Êä³ö¹¦ÂÊ/1000*ICONT*8388608 Èç£º1200/3600/220*10/1000*96
             -*8388608=576716
 411          **           channel: µçÁ÷Í¨µÀ 0-Í¨µÀ1 1-Í¨µÀ2       
 412          ** ³ö¿Ú²ÎÊý: ÎÞ 
 413          ********************************************************************************************************/
 414          void SoftAdjust_IB_Process(uint32 jzval,uint8 channel)
 415          {
 416   1         uint32 val;
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 8   

 417   1         uint32 adjust_wcval;
 418   1      
 419   1          CLRWDT();
 420   1          if(channel==EMU_CH_L)
 421   1          {
 422   2              val=0;
 423   2              SetMeterCfgACK(val,SCQ);  //Ð£Õý¹¦ÂÊÔöÒæ
 424   2              SetMeterCfgACK(val,PARAQC);   
 425   2          }
 426   1          else
 427   1          {
 428   2              val=0;
 429   2              WriteRaccoon(val,RegWAPT, BPhy);  //Ð£Õý¹¦ÂÊÔöÒæ
 430   2              //SetMeterCfgACK(val,PARAQC);   
 431   2             WriteRaccoon(val,RegWWAPT, BPhy);  // ½Ç²î  
 432   2          }
 433   1         adjust_wcval=Get_Original_Power(2,channel); 
 434   1         val = CalculateSC(adjust_wcval,jzval);
 435   1         
 436   1          CLRWDT(); 
 437   1          if(channel==EMU_CH_L)
 438   1          {
 439   2              gs_adj_emu_param.w2gain=val;      
 440   2          }
 441   1          else
 442   1          {
 443   2              gs_adj_emu_param.w1gain=val;      
 444   2          }
 445   1      }       
 446          
 447          /*********************************************************************************************************
 448          ** º¯ÊýÃû³Æ: SoftAdjust_IB5_Process
 449          ** ¹¦ÄÜÃèÊö: Ð£×¼Ð¡¹¦ÂÊ
 450          ** Èë¿Ú²ÎÊý: jzval£ºÀíÂÛ¹¦ÂÊÖµ Âö³å³£Êý/3600*±íÌ¨Êä³ö¹¦ÂÊ/1000*ICONT*8388608 Èç£º1200/3600/220*0.5/1000*96
             -*8388608=28835
 451          **           channle:µçÁ÷Í¨µÀºÅ 0-Í¨µÀ1  1-Í¨µÀ2
 452          ** ³ö¿Ú²ÎÊý: ÎÞ 
 453          ********************************************************************************************************/
 454          void SoftAdjust_IB5_Process(uint32 jzval,uint8 channel)
 455          {
 456   1         bit Flag_fu=0;   //¸ººÅ±êÖ¾  
 457   1      
 458   1         uint32 val;           
 459   1         uint32 adjust_wcval;
 460   1                    
 461   1      
 462   1          CLRWDT();
 463   1          val=0;
 464   1          if(channel==EMU_CH_L)
 465   1          {
 466   2              SetMeterCfgACK(val,PARAQC);   
 467   2          }
 468   1          else
 469   1          {
 470   2              //SetMeterCfgACK(val,PARAQC);   
 471   2             WriteRaccoon(val,RegWWAPT, BPhy);  //¶þ´Î²¹³¥
 472   2          }
 473   1         adjust_wcval=Get_Original_Power(3,channel); 
 474   1         val = CalculateAC(adjust_wcval,jzval);
 475   1      
 476   1          CLRWDT(); 
 477   1          if(channel==EMU_CH_L)
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 9   

 478   1          {
 479   2              gs_adj_emu_param.watt2os=val;      
 480   2          }
 481   1          else
 482   1          {
 483   2              gs_adj_emu_param.watt1os=val;      
 484   2          }
 485   1      
 486   1      }
 487                                  
 488          /*********************************************************************************************************
 489          ** º¯ÊýÃû³Æ: SoftAdjust_Phase_Process
 490          ** ¹¦ÄÜÃèÊö: ¹¦ÂÊÐ£×¼ÏàÎ»
 491          ** Èë¿Ú²ÎÊý: jzval£ºÀíÂÛ¹¦ÂÊÖµ Âö³å³£Êý/3600*±íÌ¨Êä³ö¹¦ÂÊ/1000*ICONT*8388608 Èç£º1200/3600/220*5/1000*96*8
             -388608=288358
 492          **           channel£ºÍ¨µÀºÅ
 493          ** ³ö¿Ú²ÎÊý: ÎÞ 
 494          ********************************************************************************************************/
 495          void SoftAdjust_Phase_Process(uint32 jzval,uint8 channel)
 496          {   
 497   1         uint32 val;           
 498   1         uint32 adjust_wcval;
 499   1        
 500   1                 
 501   1      
 502   1          CLRWDT();
 503   1          val=0;
 504   1          if(channel==EMU_CH_L)
 505   1          {
 506   2              SetMeterCfgACK(val,PHCCtrl2);   
 507   2          }
 508   1          else
 509   1          {
 510   2               WriteRaccoon(0x000B00A9 ,RegMTPARA1, BPhy);  // ½Ç²î  
 511   2          }
 512   1          CLRWDT();
 513   1      
 514   1          gs_emu_adj_var.sec_flg=FALSE;
 515   1          while(gs_emu_adj_var.sec_flg==FALSE);              //ÑÓÊ±1Ãë µÈ´ý¹¦ÂÊÎÈ¶¨
 516   1          gs_emu_adj_var.sec_flg=FALSE; 
 517   1      
 518   1         adjust_wcval=Get_Original_Power(2,channel); 
 519   1         val = CalculateAC(adjust_wcval,jzval);
 520   1         
 521   1          CLRWDT(); 
 522   1          if(channel==EMU_CH_L)
 523   1          {
 524   2              gs_adj_emu_param.p2cal=val;      
 525   2          }
 526   1          else  //   
 527   1          {
 528   2               if(val&BIT7)  //¸ºÖµ
 529   2               {
 530   3                val&=~0x00000080;
 531   3                val = (val*1.1f);
 532   3                val =(val<<8);
 533   3                val|=(0x00040000);  //bit18Î» Ð´Èë1 ÑÓÊ±µçÑ¹
 534   3               }
 535   2               else
 536   2               {
 537   3                val = (val*1.1f);
 538   3                val =(val<<8);
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 10  

 539   3                val&=(~0x00040000);//  È¡Ïû·ûºÅÎ»
 540   3               }
 541   2               gs_adj_emu_param.p2cal = 0x000B00A9;
 542   2               gs_adj_emu_param.p2cal |=val;
 543   2          }
 544   1      
 545   1      }
 546                
 547          /*********************************************************************************************************
 548          ** º¯ÊýÃû³Æ: SoftAdjust_dlxProcess      
 549          ** ¹¦ÄÜÃèÊö: Ð£×¼µ÷ÁãÏßÐ£×¼
 550          ** Èë¿Ú²ÎÊý: jzval£ºÀíÂÛ¹¦ÂÊÖµ Âö³å³£Êý/3600*±íÌ¨Êä³ö¹¦ÂÊ/1000*ICONT*8388608 Èç£º1200/3600/220*5/1000*96*8
             -388608=288358
 551          **           channel£ºÍ¨µÀºÅ
 552          ** ³ö¿Ú²ÎÊý: ÎÞ 
 553          ********************************************************************************************************/
 554          //void SoftAdjust_dlxProcess(uint32 jzval,uint8 channel)
 555          //{
 556          //    uint32 xdata adjust_wcval;
 557          
 558          //    CLRWDT();
 559          //    Init_EMU(DLX_MODE);
 560          //    gs_emu_adj_var.sec_flg=FALSE;
 561          //    while(gs_emu_adj_var.sec_flg==FALSE);              //ÑÓÊ±1Ãë µÈ´ý¹¦ÂÊÎÈ¶¨
 562          //    gs_emu_adj_var.sec_flg=FALSE; 
 563          //    CLRWDT();
 564          
 565          //    gs_emu_adj_var.sec_flg=FALSE;
 566          //    while(gs_emu_adj_var.sec_flg==FALSE);              //ÑÓÊ±1Ãë µÈ´ý¹¦ÂÊÎÈ¶¨
 567          //    gs_emu_adj_var.sec_flg=FALSE;    
 568          //    CLRWDT();
 569          
 570          //    if(channel==EMU_CH_L)
 571          //    {
 572          //        //Dis_Adjust(7);              
 573          //        adjust_wcval=Get_Original_Irms(3,EMU_CH_L);           //¶ÁÈ¡AÍ¨µÀÊµ¼Ê µçÁ÷ÓÐÐ§ÖµÊý¾Ý //
 574          //       gs_adj_emu_param.vconst_val_ch1 =((float) jzval)/((float) adjust_wcval);   //»ñÈ¡AÍ¨µÀµÄ³£Êý¼ÆÁ¿Ï
             -µÊý //
 575          //    }
 576          //    else
 577          //    {
 578          //        //Dis_Adjust(8);
 579          //        adjust_wcval=Get_Original_Irms(3,EMU_CH_N);   //¶ÁÈ¡BÍ¨µÀÊµ¼Ê µçÁ÷ÓÐÐ§ÖµÊý¾Ý //
 580          //        gs_adj_emu_param.vconst_val_ch2 =((float) jzval)/((float) adjust_wcval);   //»ñÈ¡BÍ¨µÀµÄ³£Êý¼ÆÁ¿
             -ÏµÊý //
 581          //    }
 582          
 583          //    CLRWDT();
 584          //    Init_EMU(NORMAL_MODE);
 585          //    Save_EMU_AdjParam();
 586          //    Check_EMU_AdjParam();
 587          //    NOP();
 588          //    NOP();
 589          //}
 590          
 591          
 592          //ÎÞ¹¦²¹³¥
 593          uint32 CalculateSChz(int16 error,int32 LastSC)
 594          {
 595   1          //¼ÆËã¹«Ê½¸ü»»,À×ÎÄ±ó£¬2011Äê7ÔÂ14ÈÕ
 596   1          int16 Error;                    
 597   1          uint16 Stemp0remd,Stemp2remd;  
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 11  

 598   1          int32 Stemp0,Stemp1,Stemp2,Stemp3;//
 599   1          uint32 Result;
 600   1          //¹«Ê½ËµÃ÷ ¼ÆËãÎó²î¹«Ê½ S=2^31(1/(1+e)-1)+S1(1/(1+e)),Èç¹ûeÀ©´ó1000±¶ºó£¬
 601   1          //»¯½â¹«Ê½µÃ:  S=  2^31(-e/(1000+e))+S1(1000/(1000+e)=S1(1000/(1000+e)-2^31(e/(1000+e))
 602   1          //ÏÂÃæ¼ÆËã  2^31(e/(1000+e))
 603   1          Error=error;                                                               //¼ÆËãÎó²îÖµ¡£¡£À©´ó1000
 604   1          Stemp0=0x80000000/(1000+Error);                     //ÏÈ±£ÁôÕûÊý²¿·Ö 2^31/(1000+e)=0x80000000/(1000+e)
 605   1          Stemp0remd=0x80000000%(1000+Error);                 //±£ÁôÓàÊý
 606   1          Stemp0remd=Stemp0remd*1000/(1000+Error);            //¼ÆËãÐ¡Êý²¿·Ö£¬Ð¡Êý²¿·ÖÀ©´ó1000
 607   1          Stemp1=Stemp0*Error+(Stemp0remd*Error)/1000;        //°Ñ¼ÆËãµÄÕûÊýºÍÐ¡Êý²¿·Ö¶¼³ËÒÔERROR£¬µÃ2^31(e/(100
             -0+e))
 608   1          //ÏÂÃæ¼ÆËãS1*(1000/(1000+e)
 609   1          Stemp2=LastSC/(1000+Error);                         //¼ÆËãÕûÊý²¿·Ö
 610   1          Stemp2remd=LastSC%(1000+Error);                     //¼ÆËãÓàÊý²¿·Ö
 611   1          Stemp2remd=Stemp2remd*1000/(1000+Error);            //Ð¡Êý²¿·Ö
 612   1          Stemp3=Stemp2*1000+Stemp2remd;                      //ÕûÊý²¿·Ö¼ÓÐ¡Êý²¿·Ö  
 613   1      
 614   1          Result=Stemp3-Stemp1;                               //S=S1(1000/(1000+e)-2^31(e/(1000+e))
 615   1          return Result;
 616   1       
 617   1      }
 618          void TimeEventProc(void)
 619          {
 620   1          static uint32 temp=0;
 621   1          uint16 HZ;
 622   1              
 623   1              HZ = 8192000/ReadMeterParaACK(0x10fd);
 624   1              if(temp != HZ) 
 625   1              {
 626   2                  temp = HZ;
 627   2                  if(HZ > 500)
 628   2                  {
 629   3                      gs_adj_emu_param.w2gain = CalculateSChz((HZ -500)*2,gs_adj_emu_param.w1gain);  //Ã¿¸ô0.1hz²¹0.2%
 630   3                      SetMeterCfgACK(gs_adj_emu_param.w2gain,SCQ);     
 631   3                  }
 632   2                  else if(HZ < 500)
 633   2                  {
 634   3                      gs_adj_emu_param.w2gain = CalculateSChz(-(500 -HZ)*2,gs_adj_emu_param.w1gain);
 635   3                      SetMeterCfgACK(gs_adj_emu_param.w2gain,SCQ); 
 636   3                  }
 637   2                  else
 638   2                  {
 639   3                      SetMeterCfgACK(gs_adj_emu_param.w1gain,SCQ); 
 640   3                      gs_adj_emu_param.w2gain = gs_adj_emu_param.w1gain;
 641   3                  }
 642   2              }
 643   1      
 644   1      }
 645          /*********************************************************************************************************
 646          ** º¯ÊýÃû³Æ: Hardware_AdjustDiv_Sub
 647          ** ¹¦ÄÜÃèÊö: Ó²¼þ¶Ì½Ó Ð£×¼²½ÖèÅÐ¶Ï
 648          ** Èë¿Ú²ÎÊý: ÎÞ
 649          ** ³ö¿Ú²ÎÊý: ÎÞ
 650          ********************************************************************************************************/
 651          void Hardware_AdjustDiv_Sub(void)
 652          {
 653   1         uint8 i;
 654   1          uint32 val;
 655   1         uint32 tmpval;
 656   1         uint32 tmpval1=0;     
 657   1         uint32 jzwcval;
 658   1         uint8 ajust1_type; // AÂ·Ð£±í²½Öè
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 12  

 659   1          uint8 ajust2_type;// BÂ·Ð£±í²½Öè
 660   1          uint32 cmp_val[4];//  Ð£±íµã¹¦ÂÊãÐÖµ
 661   1         uint32 adjust1_wcval;  // A Â·Ð£±í¹¦ÂÊ
 662   1      //   uint32 adjust2_wcval;  // BÂ·Ð£±í¹¦ÂÊ
 663   1         ST_U32_U08 TempValue;
 664   1      
 665   1          if(EA==0)  return;
 666   1      
 667   1          //  ×¼±¸½×¶Î  £¬»ñÈ¡¹¦ÂÊÖµ£¬ÅÐ¶Ï½øÐÐÄÄÒ»²½µÄÐ£±í//
 668   1          gs_emu_adj_var.adj_flg =0x55;   // =0X55 ±êÊ¶Ä¿Ç°½øÈëÐ£±í×´Ì¬ //
 669   1      
 670   1          jzwcval=cst_adj_const.C_PCONST;     // ¶î¶¨¹¦ÂÊµãµÄ¹¦ÂÊÐ£×¼¶¨µãÊý¾Ý//
 671   1          cmp_val[0]=jzwcval*25/10;         //250% IB »ù±¾Ð£±íµã²ÎÊý²ÉÓÃÄ¬ÈÏÖµ³õÊ¼»¯ //
 672   1          cmp_val[1]=jzwcval*70/100;       // »ù±¾µãÐ£×¼ //
 673   1          cmp_val[2]=jzwcval*35/100;       // ½Ç²îÐ£×¼ //
 674   1          cmp_val[3]=jzwcval*3/100;         // Ð¡ÐÅºÅÐ£×¼ //
 675   1      
 676   1          CLRWDT();   
 677   1      
 678   1      // AÂ·×¼±¸       
 679   1          adjust1_wcval=Get_Original_Power(4,EMU_CH_L);        //¶ÁÈ¡Êµ¼Ê¹¦ÂÊ
 680   1          if(adjust1_wcval>cmp_val[0])
 681   1          {
 682   2              ajust1_type=HARD_EADJ_STEP0_L_INITLIZE;//IB 1.0 ch0;
 683   2          }
 684   1          else if(adjust1_wcval>cmp_val[1])
 685   1          {
 686   2              ajust1_type=HARD_EADJ_STEP1_L_100IB_100L;//IB 1.0 ch0;
 687   2          }
 688   1          else if(adjust1_wcval>cmp_val[2])
 689   1          {
 690   2              ajust1_type=HARD_EADJ_STEP2_L_100IB_50L;//IB 0.5 ch0;   
 691   2          }   
 692   1          else if(adjust1_wcval>cmp_val[3])
 693   1          {
 694   2              ajust1_type=HARD_EADJ_STEP3_L_5IB_100L;//5%IB 1.0 ch0;   
 695   2          }
 696   1          else 
 697   1          {
 698   2              ajust1_type=HARD_EADJ_STEP8_METER_CLR;//5%IB 1.0 ch0;   
 699   2              }
 700   1      
 701   1              
 702   1       // BÂ·×´Ì¬//
 703   1         /*    adjust2_wcval = Get_Original_Power(4,EMU_CH_N);
 704   1      
 705   1              if(adjust2_wcval>cmp_val[0])
 706   1              {
 707   1                  ajust2_type=HARD_EADJ_STEP4_N_INITLIZE;//IB 1.0 ch0;
 708   1              }
 709   1              else if(adjust2_wcval>cmp_val[1])
 710   1              {
 711   1                  ajust2_type=HARD_EADJ_STEP5_N_100IB_100L;//IB 1.0 ch1;
 712   1              }
 713   1              else if(adjust2_wcval>cmp_val[2])
 714   1              {
 715   1                  ajust2_type=HARD_EADJ_STEP6_N_100IB_50L;//IB 0.5 ch1;     
 716   1              }   
 717   1              else if(adjust2_wcval>cmp_val[3])
 718   1              {
 719   1                  ajust2_type=HARD_EADJ_STEP7_N_5IB_100L;//5%IB 1.0 ch1;   
 720   1              }
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 13  

 721   1              else
 722   1              {
 723   1                  ajust2_type=HARD_EADJ_STEP8_METER_CLR;// µç±íÇåÁã  //   
 724   1              }
 725   1      
 726   1      */
 727   1          //   ·Ö²½ÖèÐ£×¼´¦Àí   //
 728   1        // AÂ·//
 729   1          //  HARD_EADJ_STEP0_L_INITLIZE   L»ØÂ·±È²î¼Ä´æÆ÷³õÊ¼»¯//
 730   1          if(ajust1_type==HARD_EADJ_STEP0_L_INITLIZE)
 731   1          {                      
 732   2              gs_adj_emu_param.w2gain = 0;   //³õÊ¼»¯L1Í¨µÀ±È²î¼Ä´æÆ÷  //
 733   2              gs_adj_emu_param.p2cal = 0;   //³õÊ¼»¯L1Í¨µÀ±È²î¼Ä´æÆ÷  //
 734   2                      api_chg_LCDDisplay_adj_item(DIS_ADJ_CH1_0);   // Òº¾§ÏÔÊ¾ //
 735   2          }
 736   1      
 737   1          //  HARD_EADJ_STEP1_L_100IB_100L   L»ØÂ·100%Ib, 1.0L Ð£×¼//
 738   1          if(ajust1_type==HARD_EADJ_STEP1_L_100IB_100L)
 739   1          {                      
 740   2              // L»ØÂ·ÓÐ¹¦ÔöÒæÐ£×¼ // 
 741   2              SoftAdjust_IB_Process(jzwcval,EMU_CH_L); 
 742   2      
 743   2              // L»ØÂ·µçÁ÷ÓÐÐ§ÖµÔöÒæÐ£×¼ //   
 744   2              tmpval=0;
 745   2              for(i=0;i<8;i++)
 746   2              {
 747   3                  Lib_Delay_ms(30);
 748   3                  val = ReadMeterParaACK(RMSII2); // 2017-1-12 ZWK
 749   3                  if(val>=0x80000000)
 750   3                  {
 751   4                      val=~val+1;  
 752   4                  }                           
 753   3                  tmpval=tmpval+val;
 754   3                  CLRWDT();          
 755   3              }
 756   2              tmpval=tmpval/8;
 757   2              //µçÁ÷ÓÐÐ§ÖµµÄÎ»ÊýÔÚ´Ë´¦¾ö¶¨£¬È¡¾öÓÚcst_adj_const.I_refºÍ»ù±¾µçÁ÷ÕûÊýµÄ±¶Êý//
 758   2              gs_adj_emu_param.i2rms_xs=(float)cst_adj_const.I_ref/(float)tmpval;  
 759   2              //µçÑ¹ÓÐÐ§ÖµÔöÒæÐ£×¼ //                         
 760   2              tmpval=0;
 761   2              for(i=0;i<8;i++)
 762   2              {
 763   3                  Lib_Delay_ms(30);
 764   3                  val = ReadMeterParaACK(RMSIU); // ÐÞ¸ÄÎª¶ÁÃëÆ½¾ùÖµ
 765   3                  if(val>=0x80000000)
 766   3                  {
 767   4                      val=~val+1;  
 768   4                  }                           
 769   3                  tmpval=tmpval+val;
 770   3                  CLRWDT();        
 771   3              }
 772   2                tmpval=tmpval/8;      
 773   2              //µçÑ¹ÓÐÐ§ÖµµÄÎ»ÊýÔÚ´Ë´¦¾ö¶¨£¬È¡¾öÓÚcst_adj_const.U_refºÍ»ù±¾µçÑ¹ÕûÊýµÄ±¶Êý//
 774   2              gs_adj_emu_param.vrms_xs=(float)cst_adj_const.U_ref/(float)tmpval;  
 775   2                  api_chg_LCDDisplay_adj_item(DIS_ADJ_CH1_1);   // Òº¾§ÏÔÊ¾ //
 776   2      
 777   2              CLRWDT();
 778   2          }
 779   1      
 780   1          //  HARD_EADJ_STEP2_L_100IB_50L   L»ØÂ·100%Ib, 0.5L Ð£×¼//
 781   1          if(ajust1_type==HARD_EADJ_STEP2_L_100IB_50L)
 782   1          {                            
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 14  

 783   2              jzwcval=jzwcval/2;
 784   2              SoftAdjust_Phase_Process(jzwcval,EMU_CH_L);  
 785   2              api_chg_LCDDisplay_adj_item(DIS_ADJ_CH1_2);   // Òº¾§ÏÔÊ¾ //
 786   2      
 787   2          }
 788   1          //  HARD_EADJ_STEP3_L_5IB_100L   L»ØÂ·5%Ib, 1.0L Ð£×¼//
 789   1          if(ajust1_type==HARD_EADJ_STEP3_L_5IB_100L)
 790   1          {                            
 791   2              jzwcval=jzwcval/20;
 792   2              SoftAdjust_IB5_Process(jzwcval,EMU_CH_L);   
 793   2              api_chg_LCDDisplay_adj_item(DIS_ADJ_CH1_3);   // Òº¾§ÏÔÊ¾ //
 794   2      
 795   2          }
 796   1      
 797   1      
 798   1      // 9260FÐ£±íÏà¹Ø//
 799   1      
 800   1          //  HARD_EADJ_STEP4_N_INITLIZE   N»ØÂ·±È²î¼Ä´æÆ÷³õÊ¼»¯//
 801   1          if(ajust2_type==HARD_EADJ_STEP4_N_INITLIZE)
 802   1          {                      
 803   2              gs_adj_emu_param.w2gain = 0;   //³õÊ¼»¯L1Í¨µÀ±È²î¼Ä´æÆ÷  //
 804   2              gs_adj_emu_param.p2cal= 0x000B00A9;   //³õÊ¼»¯L1Í¨µÀ±È²î¼Ä´æÆ÷  //
 805   2                  api_chg_LCDDisplay_adj_item(DIS_ADJ_CH2_0);   // Òº¾§ÏÔÊ¾ //
 806   2          }
 807   1      
 808   1          //  HARD_EADJ_STEP4_N_100IB_100L   N»ØÂ·100%Ib, 1.0L Ð£×¼//
 809   1          if(ajust2_type==HARD_EADJ_STEP5_N_100IB_100L)
 810   1          {              
 811   2              // L»ØÂ·ÓÐ¹¦ÔöÒæÐ£×¼ // 
 812   2              SoftAdjust_IB_Process(REF_RMSPn_9260,EMU_CH_N);
 813   2              tmpval=0;
 814   2              for(i=0;i<8;i++)
 815   2              {
 816   3                 if(ReadRaccoon(RegARTI,1,BPhy)==TRUE)    // ÐÞ¸ÄÎª¶ÁÃëÆ½¾ùÖµ  // ×î´ó 200ms¶ÁÈ¡µÈ´ý    //  ÀíÂÛÊ±¼ä76m
             -sRegWARTI
 817   3                 {
 818   4                      memcpy((uint8*)TempValue.B08,gs_RacCtrl.ucBuf+3,4); //ÓÐ¹¦ÃëÆ½¾ù¹¦ÂÊ
 819   4                      Lib_Rev_Copy_Arry(&TempValue.B08[0],4);// µÍ×Ö½ÚÔÚÇ°  µ¹ÖÃ//
 820   4                      val = TempValue.u32;
 821   4                 }
 822   3                 else // ¶ÁÈ¡Ê§°Ü£¬ ÖØÐÂ¶ÁÈ¡Ò»´Î// 
 823   3                 {
 824   4                      gs_sys_run.font_fg |= BIT4_FONT_FG_EnyBottom;
 825   4                 }
 826   3                  if(val>=0x80000000)
 827   3                  {
 828   4                      val=~val+1;  
 829   4                  }                           
 830   3                  tmpval=tmpval+val;
 831   3                  CLRWDT();          
 832   3              }
 833   2              tmpval=tmpval/8;
 834   2              //µçÁ÷ÓÐÐ§ÖµµÄÎ»ÊýÔÚ´Ë´¦¾ö¶¨£¬È¡¾öÓÚcst_adj_const.I_refºÍ»ù±¾µçÁ÷ÕûÊýµÄ±¶Êý//
 835   2              gs_adj_emu_param.i2rms_xs=(float)cst_adj_const.I_ref/(float)tmpval;  
 836   2      
 837   2              /// 2Â·µçÑ¹ÓÐÐ§ÖµÔöÒæÐ£×¼ //                            
 838   2              tmpval=0;
 839   2              for(i=0;i<8;i++)
 840   2              {
 841   3                 if(ReadRaccoon(RegARTU,1,BPhy)==TRUE)    // ÐÞ¸ÄÎª¶ÁÃëÆ½¾ùÖµ  // ×î´ó 200ms¶ÁÈ¡µÈ´ý    //  ÀíÂÛÊ±¼ä76m
             -s   RegWARTU
 842   3                 {
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 15  

 843   4                      memcpy((uint8*)TempValue.B08,gs_RacCtrl.ucBuf+3,4); //ÓÐ¹¦ÃëÆ½¾ù¹¦ÂÊ
 844   4                      Lib_Rev_Copy_Arry(&TempValue.B08[0],4);// µÍ×Ö½ÚÔÚÇ°  µ¹ÖÃ//
 845   4                      val = TempValue.u32;
 846   4                 }
 847   3                 else // ¶ÁÈ¡Ê§°Ü£¬ ÖØÐÂ¶ÁÈ¡Ò»´Î// 
 848   3                 {
 849   4                      gs_sys_run.font_fg |= BIT4_FONT_FG_EnyBottom;
 850   4                 }
 851   3                  if(val>=0x80000000)
 852   3                  {
 853   4                      val=~val+1;  
 854   4                  }                           
 855   3                  tmpval=tmpval+val;
 856   3                  CLRWDT();        
 857   3              }
 858   2              tmpval=tmpval/8;      
 859   2              //µçÑ¹ÓÐÐ§ÖµµÄÎ»ÊýÔÚ´Ë´¦¾ö¶¨£¬È¡¾öÓÚcst_adj_const.U_refºÍ»ù±¾µçÑ¹ÕûÊýµÄ±¶Êý//
 860   2              gs_adj_emu_param.vrms_xs=(float)cst_adj_const.U_ref/(float)tmpval;  
 861   2                  api_chg_LCDDisplay_adj_item(DIS_ADJ_CH2_1);   // Òº¾§ÏÔÊ¾ //
 862   2          }
 863   1      
 864   1          if(ajust2_type==HARD_EADJ_STEP6_N_100IB_50L)
 865   1          {                      
 866   2              jzwcval=jzwcval/2;
 867   2              SoftAdjust_Phase_Process(jzwcval,EMU_CH_N);  
 868   2              api_chg_LCDDisplay_adj_item(DIS_ADJ_CH2_2);   // Òº¾§ÏÔÊ¾ //            
 869   2          }    
 870   1          //  HARD_EADJ_STEP7_N_5IB_100L   N»ØÂ·5%Ib, 1.0L Ð£×¼//
 871   1          if(ajust2_type==HARD_EADJ_STEP7_N_5IB_100L)
 872   1          {                         
 873   2              jzwcval=jzwcval/20;
 874   2              SoftAdjust_IB5_Process(jzwcval,EMU_CH_N);   
 875   2              api_chg_LCDDisplay_adj_item(DIS_ADJ_CH2_3);   // Òº¾§ÏÔÊ¾ //   
 876   2          }
 877   1      
 878   1          if((ajust2_type==HARD_EADJ_STEP8_METER_CLR)&&(ajust1_type==HARD_EADJ_STEP8_METER_CLR))
 879   1          {        
 880   2              api_clr_current_energy_data(); // µçÁ¿ÇåÁã//
 881   2              CLRWDT();
 882   2               //   api_clr_current_MD_data(); //µ±Ç°ÐèÁ¿ÇåÁã
 883   2              CLRWDT();
 884   2      
 885   2      #if (BILL_MAX_NUM>0)
 886   2                  api_clr_bill_data();
 887   2      #endif
 888   2                  gs_uart_iec_app_var[g_ch_comm].delay_10ms = 0; // 
 889   2              CLRWDT();
 890   2                  //api_deal_even_class_recode(ID_CLASS_I_resetMD,START);
 891   2                  api_chg_LCDDisplay_adj_item(DIS_DATA_CLR);   // Òº¾§ÏÔÊ¾ //
 892   2          }
 893   1      
 894   1          Save_EMU_AdjParam();
 895   1          Check_EMU_AdjParam();
 896   1          CLRWDT();
 897   1          gs_emu_adj_var.adj_flg =0;   // =0X0 ±êÊ¶Ä¿Ç°ÍË³öÐ£±í×´Ì¬ //        
 898   1      
 899   1      }
 900          //////////////ÒÔÏÂÎªÐÂÔöÈí¼þÐ£×¼²½Öè yang 2017-12-26/////////////////
 901          //-------------------------------------------------------------------------------//
 902          //  Function:      Measure_Electric_Parameter_Per_Sec(void)      
 903          //  Description: ½Ï±íÔöÒæ¼ÆËãGain//
 904          //  Parameters:   ÎÞ  
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 16  

 905          //  Returns:        ÎÞ                          
 906          //  Others:   xxx.xxV   xx.xxx A  xxxx.x W     
 907          //-------------------------------------------------------------------------------//
 908          void Measure_Electric_Err_Gain(INT8U *sptr)
 909          {   
 910   1              union Union_DWordDef u32_tmp_U,u32_tmp_A,u32_tmp_P,u32_tmp;
 911   1      
 912   1               char errbuf[7];
 913   1               float Err_Data;        
 914   1              ///Voltage///
 915   1              u32_tmp.BYTE[0]=0;      
 916   1              u32_tmp.BYTE[1]=Lib_AtoB(*(sptr+13));
 917   1              u32_tmp.BYTE[2]=((Lib_AtoB(*(sptr+14)))<<4) + Lib_AtoB(*(sptr+15));
 918   1              u32_tmp.BYTE[3]=((Lib_AtoB(*(sptr+17)))<<4) + Lib_AtoB(*(sptr+18));
 919   1              u32_tmp_U.UDWORD = Lib_bcd4_long(&u32_tmp.BYTE[0]);
 920   1              ///Current///
 921   1              u32_tmp.BYTE[0]=0;      
 922   1              u32_tmp.BYTE[1]=Lib_AtoB(*(sptr+19));
 923   1              u32_tmp.BYTE[2]=((Lib_AtoB(*(sptr+20)))<<4) + Lib_AtoB(*(sptr+22));
 924   1              u32_tmp.BYTE[3]=((Lib_AtoB(*(sptr+23)))<<4) + Lib_AtoB(*(sptr+24));
 925   1              u32_tmp_A.UDWORD = Lib_bcd4_long(&u32_tmp.BYTE[0]);
 926   1              ///Active Power///
 927   1              u32_tmp.BYTE[0]=0;      
 928   1              u32_tmp.BYTE[1]=Lib_AtoB(*(sptr+25));
 929   1              u32_tmp.BYTE[2]=((Lib_AtoB(*(sptr+26)))<<4) + Lib_AtoB(*(sptr+27));
 930   1              u32_tmp.BYTE[3]=((Lib_AtoB(*(sptr+28)))<<4) + Lib_AtoB(*(sptr+30));
 931   1              u32_tmp_P.UDWORD = Lib_bcd4_long(&u32_tmp.BYTE[0]);
 932   1      
 933   1              //Îó²î×ª»»//
 934   1              Lib_Copy_Str_TwoArry( &errbuf[0], sptr+13+6+6+6,6);
 935   1              errbuf[6] = '\0';
 936   1              Err_Data = atof(&errbuf[0]);   // asc ×ª float  //
 937   1      
 938   1              switch(comm_data.di1_di0.u32)//(comm_data.di1_di0.UDWORD)
 939   1              {
 940   2                      case  0x0000FEB0:
 941   2                      case  0x0000FEB3:
 942   2                              Calibration_Power(Err_Data);    
 943   2                              CLRWDT();
 944   2                              Calibration_Current(u32_tmp_A.UDWORD,u32_tmp_U.UDWORD);
 945   2                              break;
 946   2                      case  0x0000FEB1:
 947   2                      case  0x0000FEB4:
 948   2                              Calibration_Angular(Err_Data);
 949   2                              break;
 950   2                      case  0x0000FEB2:
 951   2                      case  0x0000FEB5:
 952   2                              Calibration_small_signal(Err_Data);
 953   2                              break;
 954   2                      default :
 955   2                              return;
 956   2              }
 957   1          Save_EMU_AdjParam();
 958   1          Check_EMU_AdjParam();
 959   1          CLRWDT();
 960   1      }
 961          //***************************************************************************
 962          // ¹¦ÄÜ:   Í¨Ñ¶ÖÐµ÷ÓÃµÄÐ£×¼¹¦ÂÊÄÜÁ¿±È²îµÄº¯Êý£¨1Â·ºÍ2Â·×Ô¶¯ÅÐ¶Ï£©
 963          // ÊäÈë£º POWER£¬¸ñÊ½0.1W,16½øÖÆ
 964          // ÖÐ¼äÁ¿£ºu32PMdatal£¬Îª±È²îÐ£×¼µÄ²ÎÊý½á¹û
 965          //***************************************************************************
 966          void Calibration_Power(float f_err_data)
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 17  

 967          {
 968   1      //       INT8U  offset;
 969   1               INT32U u32_tmp;
 970   1               INT32U u32_PMdataltemp;
 971   1      
 972   1      //       static uint32 temp=0;
 973   1      //       uint16 HZ;
 974   1              CLRWDT();
 975   1      
 976   1          if(f_err_data>0)
 977   1          {
 978   2              u32_tmp = 100000*(100+f_err_data) ;   
 979   2          }
 980   1          else
 981   1          {
 982   2              u32_tmp = 100000*(100+f_err_data) ;  //-
 983   2          }
 984   1      #if meter_type == D_1P3W
              
                      if(comm_data.di1_di0.u32 == 0x0000FEB3)    // DI03B  IA×÷ÎªN»ØÂ·
                      {
              
                              u32_PMdataltemp=ReadMeterParaACK(SCP);  
                              u32_PMdataltemp=CalculateSC(u32_tmp,10000000);  
                              SetMeterCfgACK(u32_PMdataltemp,SCP);
                      gs_adj_emu_param.w1gain=u32_PMdataltemp;      
                      }
                      else if(comm_data.di1_di0.u32 == 0x0000FEB0)  // DI03B  IB×÷ÎªÖ÷»ØÂ·  //
                      {
                              u32_PMdataltemp=ReadMeterParaACK(SCQ);
                              u32_PMdataltemp=CalculateSC(u32_tmp,10000000);  
                              SetMeterCfgACK(u32_PMdataltemp,SCQ);
                      gs_adj_emu_param.w2gain=u32_PMdataltemp;      
                      }
              #endif
1002   1      
1003   1      #if meter_type == D_1P2W
1004   1              if(comm_data.di1_di0.u32 == 0x0000FEB0)    // DI03B  IA×÷ÎªN»ØÂ·
1005   1              {
1006   2      
1007   2                      u32_PMdataltemp=ReadMeterParaACK(SCP);  
1008   2                      u32_PMdataltemp=CalculateSC(u32_tmp,10000000);  
1009   2                      SetMeterCfgACK(u32_PMdataltemp,SCP);
1010   2              gs_adj_emu_param.w1gain=u32_PMdataltemp;
1011   2                           
1012   2              }
1013   1      
1014   1      #endif
1015   1      }
1016          
1017          
1018          //***************************************************************************
1019          // ¹¦ÄÜ:   Í¨Ñ¶ÖÐµ÷ÓÃµÄÐ£×¼µçÑ¹µçÁ÷µÄº¯Êý£¨1Â·ºÍ2Â·×Ô¶¯ÅÐ¶Ï£©
1020          // ÊäÈë£º Current£¬¸ñÊ½0.001A,16½øÖÆ
1021          //        Voltage, ¸ñÊ½0.01V,16½øÖÆ
1022          // ÖÐ¼äÁ¿£ºu32PMdatal£¬Îª±È²îÐ£×¼µÄ²ÎÊý½á¹û
1023          //***************************************************************************
1024          void  Calibration_Current(INT32U Current,INT32U Voltage)
1025          {
1026   1               INT32U u32_tmp,u32_PMdataltemp,u32_PMdataltempSII1;
1027   1        
1028   1              if(comm_data.di1_di0.u32 == 0x0000FEB0)    // DI03B  IA×÷ÎªN»ØÂ·  //0x0000FEB3 <-> 0x0000FEB0
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 18  

1029   1              {
1030   2                      // µçÁ÷Ð£×¼ //
1031   2                  u32_tmp = ReadMeterParaACK(RMSI1);
1032   2                      u32_tmp *= gs_adj_emu_param.i1rms_xs;//»ñÈ¡µçÁ÷ÏÔÊ¾Öµ yang 2017-12-28
1033   2                      u32_PMdataltemp = ReadMeterParaACK(SCI1);
1034   2                      if(u32_PMdataltemp == 0)
1035   2                      {
1036   3                              //Î´Ð£×¼£¬ÐèÒª½øÐÐÐ£×¼ //
1037   3                              u32_PMdataltemp =CalculateSC(u32_tmp,Current);  
1038   3                              gs_adj_emu_param.irms1os=u32_PMdataltemp;
1039   3                      }
1040   2      
1041   2                      // µçÑ¹Ð£×¼ //
1042   2                      u32_tmp = ReadMeterParaACK(RMSU);
1043   2                      u32_tmp *= (gs_adj_emu_param.vrms_xs*10);//»ñÈ¡µçÑ¹ÏÔÊ¾Öµ yang 2017-12-28
1044   2                      u32_PMdataltemp =ReadMeterParaACK(SCU);
1045   2                      if(u32_PMdataltemp == 0) 
1046   2                      {
1047   3                              //Î´Ð£×¼£¬ÐèÒª½øÐÐÐ£×¼ //
1048   3                              u32_PMdataltemp=CalculateSC(u32_tmp,Voltage);
1049   3                              gs_adj_emu_param.urmsos=u32_PMdataltemp;
1050   3                              SetMeterCfgACK(u32_PMdataltemp,SCU);
1051   3                      }
1052   2              }
1053   1              else if(comm_data.di1_di0.u32 == 0x0000FEB3)  // DI03B  IB×÷ÎªÖ÷»ØÂ·  //
1054   1              {
1055   2                      // µçÁ÷Ð£×¼ //
1056   2                      u32_tmp = ReadMeterParaACK(RMSI2);
1057   2                      u32_tmp*= gs_adj_emu_param.i2rms_xs;//»ñÈ¡µçÁ÷µÄÏÔÊ¾Öµ yang 2017-12-28
1058   2                      u32_PMdataltemp = ReadMeterParaACK(SCI2);
1059   2                      if(u32_PMdataltemp == 0)
1060   2                      {
1061   3                              //Î´Ð£×¼£¬ÐèÒª½øÐÐÐ£×¼ //
1062   3                              u32_PMdataltemp =CalculateSC(u32_tmp,Current);  
1063   3                              gs_adj_emu_param.irms2os=u32_PMdataltemp;
1064   3                      }
1065   2      
1066   2                      // µçÑ¹Ð£×¼ //
1067   2                      u32_tmp = ReadMeterParaACK(RMSU);
1068   2                      u32_tmp *= (gs_adj_emu_param.vrms_xs*10);//»ñÈ¡µçÑ¹ÏÔÊ¾Öµ yang 2017-12-28
1069   2                      u32_PMdataltemp =ReadMeterParaACK(SCU);
1070   2                      if(u32_PMdataltemp == 0) 
1071   2                      {
1072   3                              //Î´Ð£×¼£¬ÐèÒª½øÐÐÐ£×¼ //
1073   3                              u32_PMdataltemp=CalculateSC(u32_tmp,Voltage);
1074   3                              gs_adj_emu_param.urmsos=u32_PMdataltemp;
1075   3                              SetMeterCfgACK(u32_PMdataltemp,SCU);
1076   3                      }
1077   2              }
1078   1      
1079   1      
1080   1              
1081   1      }
*** WARNING C280 IN LINE 1026 OF ..\C_SOURCE\S1_HARDDRV\V9811A_EMU\LNK_EMU_ADJ.C: 'u32_PMdataltempSII1': unreferenced lo
             -cal variable
1082          
1083          //***************************************************************************
1084          // ¹¦ÄÜ:   ¹¦ÂÊÄÜÁ¿½Ç²îÐ£×¼£¨1Â·ºÍ2Â·×Ô¶¯ÅÐ¶Ï£©
1085          // ÊäÈë£º POWER£¬¸ñÊ½0.1W,16½øÖÆ
1086          // ÖÐ¼äÁ¿£ºu32PMdatal£¬Îª½Ç²îÐ£×¼µÄ²ÎÊý½á¹û
1087          //***************************************************************************
1088          void Calibration_Angular(float f_err_data)
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 19  

1089          {
1090   1              INT32U u32_tmp,u32_PMdataltemp;
1091   1      //      INT8U  offset;
1092   1              union Union_DWordDef    PHCCTRL1_adj_val;       // I1 ½Ç²îµ÷½Ú¼Ä´æÆ÷ Êµ¼ÊÎª8Î»  //
1093   1              union Union_DWordDef    PHCCTRL2_adj_val;       // I2 ½Ç²îµ÷½Ú¼Ä´æÆ÷ Êµ¼ÊÎª8Î»  //
1094   1          if(f_err_data>0)
1095   1          {
1096   2              u32_tmp = 100000*(100+f_err_data) ;   
1097   2          }
1098   1          else
1099   1          {
1100   2              u32_tmp = 100000*(100+f_err_data) ;  //-
1101   2          }
1102   1      
1103   1          u32_PMdataltemp=(INT32U)CalculateAC(u32_tmp,10000000);      
1104   1      #if meter_type == D_1P3W
                      if(comm_data.di1_di0.u32 == 0x0000FEB4)    // DI03B  IA×÷ÎªN»ØÂ·  
                      {
                              /*u32_PMdataltemp =ReadMeterParaACK(DATAP);
                              if (u32_PMdataltemp&0x80000000)
                              {    
                              u32_PMdataltemp = ~u32_PMdataltemp+1;
                              } 
                              u32_tmp= u32_PMdataltemp*10;
                              u32_tmp /=K_RMSP;
                              //offset=113;   // 2»ØÂ·µÄÈË¹¤¸ÉÔ¤²¹³¥Öµ  //  0.6
                              offset=0;
                              */
                              gs_adj_emu_param.p1cal=u32_PMdataltemp;
                              Lib_long_bcd4(&PHCCTRL1_adj_val.BYTE[0],u32_PMdataltemp);
                              SetMeterCfgACK(PHCCTRL1_adj_val.BYTE[3],PHCCtrl1);  //ÉèÖÃI1½Ç²îÖµ
                      }
                      else if(comm_data.di1_di0.u32 == 0x0000FEB1)   // DI03B  IB×÷ÎªÖ÷»ØÂ·  //       
                      {
                              /*
                              u32_PMdataltemp =ReadMeterParaACK(DATAQ);
                              if (u32_PMdataltemp&0x80000000)
                              {    
                                      u32_PMdataltemp = ~u32_PMdataltemp+1;
                              } 
                              u32_tmp= u32_PMdataltemp*10;
                              u32_tmp /=K_RMSQ;
                              u32_PMdataltemp=(INT32U)CalculateAC(u32_tmp,POWER);     
                              */
                              gs_adj_emu_param.p2cal=u32_PMdataltemp;
                              Lib_long_bcd4(&PHCCTRL2_adj_val.BYTE[0],u32_PMdataltemp);
                              SetMeterCfgACK(PHCCTRL2_adj_val.BYTE[3],PHCCtrl2);  //ÉèÖÃI2½Ç²îÖµ
              
                      }
              #endif
1139   1      #if meter_type == D_1P2W
1140   1              if(comm_data.di1_di0.u32 == 0x0000FEB1)    // DI03B  IA×÷ÎªN»ØÂ·  
1141   1              {
1142   2                      gs_adj_emu_param.p1cal=u32_PMdataltemp;
1143   2                      Lib_long_bcd4(&PHCCTRL1_adj_val.BYTE[0],u32_PMdataltemp);
1144   2                      SetMeterCfgACK(PHCCTRL1_adj_val.BYTE[3],PHCCtrl1);  //ÉèÖÃI1½Ç²îÖµ
1145   2              }
1146   1              else if(comm_data.di1_di0.u32 == 0x0000FEB4)   // DI03B  IB×÷ÎªÖ÷»ØÂ·  //       
1147   1              {
1148   2                      gs_adj_emu_param.p2cal=u32_PMdataltemp;
1149   2                      Lib_long_bcd4(&PHCCTRL2_adj_val.BYTE[0],u32_PMdataltemp);
1150   2                      SetMeterCfgACK(PHCCTRL2_adj_val.BYTE[3],PHCCtrl2);  //ÉèÖÃI2½Ç²îÖµ
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 20  

1151   2      
1152   2              }
1153   1      #endif
1154   1      
1155   1      }
1156          
1157          //***************************************************************************
1158          // ¹¦ÄÜ:   Ð¡ÐÅºÅ²¹³¥£¨£©
1159          // ÊäÈë£º POWER£¬¸ñÊ½0.1W,16½øÖÆ
1160          // ÖÐ¼äÁ¿£º
1161          //***************************************************************************
1162          void Calibration_small_signal(float f_err_data)
1163          {
1164   1               INT32U u32_PMdataltemp;
1165   1               INT8U  offset;
1166   1               INT32S s32_tmp,s32_PMdataltemp;
1167   1      
1168   1      #if meter_type == D_1P3W
                      if(comm_data.di1_di0.u32 == 0x0000FEB5)          // DI03B  IA×÷ÎªN»ØÂ·  
                      {
                              s32_PMdataltemp=ReadMeterParaACK(DATAP);
                      
                              s32_tmp = (INT32S)((float)f_err_data *s32_PMdataltemp/100.0);
              
                              offset=0;    //2»ØÂ·µÄÈË¹¤¸ÉÔ¤²¹³¥Öµ  //
                              if(s32_tmp>0) u32_PMdataltemp = s32_tmp;
                              else    u32_PMdataltemp =       0xFFFFFFFF +s32_tmp;
                              
              
                              SetMeterCfgACK(u32_PMdataltemp,PARAPC);
                      gs_adj_emu_param.watt1os=u32_PMdataltemp;      
                      }
              
                      else if(comm_data.di1_di0.u32 == 0x0000FEB2)    // DI03B  IB×÷ÎªÖ÷»ØÂ·  //
                      {
                              s32_PMdataltemp=ReadMeterParaACK(DATAQ);
                      
                              s32_tmp = (INT32S)((float)f_err_data *s32_PMdataltemp/100.0);
              
                              offset=0;    //2»ØÂ·µÄÈË¹¤¸ÉÔ¤²¹³¥Öµ  //
                              if(s32_tmp>0) u32_PMdataltemp = s32_tmp;
                              else    u32_PMdataltemp =       0xFFFFFFFF +s32_tmp;
                              
              
                              SetMeterCfgACK(u32_PMdataltemp,PARAQC);
                      gs_adj_emu_param.watt2os=u32_PMdataltemp;      
                      }
              #endif
1199   1      #if meter_type == D_1P2W
1200   1              if(comm_data.di1_di0.u32 == 0x0000FEB2)          // DI03B  IA×÷ÎªN»ØÂ·  
1201   1              {
1202   2                      s32_PMdataltemp=ReadMeterParaACK(DATAP);
1203   2              
1204   2                      s32_tmp = (INT32S)((float)f_err_data *s32_PMdataltemp/100.0);
1205   2      
1206   2                      offset=0;    //2»ØÂ·µÄÈË¹¤¸ÉÔ¤²¹³¥Öµ  //
1207   2                      if(s32_tmp>0) u32_PMdataltemp = s32_tmp;
1208   2                      else    u32_PMdataltemp =       0xFFFFFFFF +s32_tmp;
1209   2                      
1210   2      
1211   2                      SetMeterCfgACK(u32_PMdataltemp,PARAPC);
1212   2              gs_adj_emu_param.watt1os=u32_PMdataltemp;      
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           03/11/2019 14:44:52 PAGE 21  

1213   2              }
1214   1      
1215   1              else if(comm_data.di1_di0.u32 == 0x0000FEB5)    // DI03B  IB×÷ÎªÖ÷»ØÂ·  //
1216   1              {
1217   2                      s32_PMdataltemp=ReadMeterParaACK(DATAQ);
1218   2              
1219   2                      s32_tmp = (INT32S)((float)f_err_data *s32_PMdataltemp/100.0);
1220   2      
1221   2                      offset=0;    //2»ØÂ·µÄÈË¹¤¸ÉÔ¤²¹³¥Öµ  //
1222   2                      if(s32_tmp>0) u32_PMdataltemp = s32_tmp;
1223   2                      else    u32_PMdataltemp =       0xFFFFFFFF +s32_tmp;
1224   2                      
1225   2      
1226   2                      SetMeterCfgACK(u32_PMdataltemp,PARAQC);
1227   2              gs_adj_emu_param.watt2os=u32_PMdataltemp;      
1228   2              }
1229   1      #endif
1230   1      
1231   1      }
1232          
1233          
1234          
1235          
1236          /////////////////////////////////////////////////////////////////////////
1237          
1238          /*******************************************************************************************
1239          **    END
1240          *******************************************************************************************/
1241          
1242          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7807    ----
   CONSTANT SIZE    =    185    ----
   XDATA SIZE       =     64     293
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

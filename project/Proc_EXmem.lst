C51 COMPILER V9.01   PROC_EXMEM                                                            03/12/2019 09:56:05 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE PROC_EXMEM
OBJECT MODULE PLACED IN .\Proc_EXmem.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\C_Source\S0_System\Proc_EXmem.c LARGE BROWSE INCDIR(..\C_Source\S0_Syste
                    -m;..\C_Source\S1_HardDrv;..\C_Source\S2_MyLib;..\C_Source\S3_ApiPlat;..\C_Source\S4_ApiUser;..\C_Source\S5_ApiProtocol;.
                    -.\C_Source\S6_MyIncludes;..\C_Source\S1_HardDrv\V9811A_EMU;..\C_Source\S1_HardDrv\V9811A_MCU;..\C_Source\S1_HardDrv\E2P_
                    -24CXXX) DEBUG OBJECTEXTEND PRINT(.\Proc_EXmem.lst) OBJECT(.\Proc_EXmem.obj)

line level    source

   1          /*
   2          *****************Copyright (c)*************************************
   3          **      Hangzhou Xili Watthour Meter Manufacture Co., Ltd. 
   4          **--------------file info--------------------------------------------
   5          **name                  : Proc_EXmem.c
   6          **Author                : maji
   7          **date                  : 2016-04-20
   8          **description   : Íâ²¿´æ´¢Æ÷´¦ÀíÏà¹ØC´úÂë
   9          **note                  : V9811A £¬MERTER FOR DL03C
  10          **--------------------Version History -------------------------------------
  11          ** NO. Date         Ver      By         Description 
  12          **==============================================================
  13          ** 1   2016-04-26   v01.00   sosomj     1. frist version                             
  14          **
  15          **==============================================================
  16          */
  17          
  18          #include <MyIncludes_H.h>
  19          
  20          // 1 E2P Êý¾Ý·ÖÇø½á¹¹¶¨Òå   //
  21          const  E2P_CHECK_TAB code  mem_table[] = {
  22              //block-0 µ±Ç°µçÁ¿Êý¾Ý¿é  //
  23              No_BLOCK00_EC_L0_E2P,      MEM_E2P1,   ADR_BLOCK00_EC_L0_E2P,  LEN_BLOCK00_EC_L0_E2P,
  24              //block-1  µ±Ç°ÔÂ×î´óÐèÁ¿Êý¾Ý¿é  //
  25              No_BLOCK01_MMD_L0_E2P,      MEM_E2P1,   ADR_BLOCK01_MMD_L0_E2P, LEN_BLOCK01_MMD_L0_E2P,
  26              //BLOCK20  µç±í²ÎÊýÇø1 //
  27              No_BLOCK20_METER_PARAM1_E2P,    MEM_E2P1,   ADR_BLOCK20_METER_PARAM1_E2P, LEN_BLOCK20_METER_PARAM1_E2P
             -,
  28                 //BLOCK21  µç±í²ÎÊýÇø-ÏÔÊ¾²ÎÊýÇø //
  29              No_BLOCK21_DIS_PARAM_E2P,    MEM_E2P1,   ADR_BLOCK21_DIS_PARAM_E2P, LEN_BLOCK21_DIS_PARAM_E2P,
  30                          //¶þÀàÊÂ¼þ²ÎÊýÇø
  31                    No_BLOCK27_EVENII_data,          MEM_E2P1,   ADR_BLOCK27_EVENII_E2P,   LEN_CLASSII_VAR,
  32              //BLOCK25 µç±í±äÁ¿Êý¾ÝÇø//
  33              No_BLOCK25_METER_VAR_E2P,    MEM_E2P1,   ADR_BLOCK25_METER_VAR_E2P, LEN_BLOCK25_METER_VAR_E2P,
  34              //BLOCK70  EMU Ð£±í²ÎÊýÇø//
  35              No_BLOCK70_EMU_PARAM_E2P,    MEM_E2P1,   ADR_BLOCK70_EMU_PARAM_E2P, LEN_BLOCK70_EMU_PARAM_E2P,
  36              //BLOCK21  µç±í²ÎÊýÇø-ÏÔÊ¾²ÎÊýÇø //
  37              No_BLOCK21_DIS_PARAM_E2P,    MEM_E2P1,   ADR_BLOCK21_DIS_PARAM_E2P, LEN_BLOCK21_DIS_PARAM_E2P,
  38           //block-81~84  ·ÑÂÊÏà¹Ø²ÎÊýÊý¾Ý¿é   //
  39          #if (TARIFF_MAX_NUM>1)
  40          #if(MAX_NUM_HOLIDAY_TAB>0)  
                  //block-81 ½Ú¼ÙÈÕ±íÊý¾Ý¿é   //
                  No_BLOCK81_HILIDAY_TAB_E2P,    MEM_E2P1,    ADR_BLOCK81_HILIDAY_TAB_E2P,    LEN_HoliTab,
              #endif
  44              //block-82 ¼¾½Ú±íÊý¾Ý¿é   //
  45              No_BLOCK82_SEASON_TAB_E2P,    MEM_E2P1,    ADR_BLOCK82_SEASON_TAB_E2P,    LEN_SeasonTab,
  46              //block-83 ÖÜ±íÊý¾Ý¿é   //
  47              No_BLOCK83_WEEK_TAB_E2P,    MEM_E2P1,    ADR_BLOCK83_WEEK_TAB_E2P,    LEN_WeekTab,
  48              //block-84 ÈÕÊ±¶Î±íÊý¾Ý¿é   //
  49              No_BLOCK84_DAY_TAB_E2P,    MEM_E2P1,    ADR_BLOCK84_DAY_TAB_E2P,    LEN_DayTab,
  50          #endif
  51              //BLOCK100~136 ÔÂ½áËãÊý¾ÝÇø  //
C51 COMPILER V9.01   PROC_EXMEM                                                            03/12/2019 09:56:05 PAGE 2   

  52          #if (BILL_MAX_NUM>0)
  53              No_BLOCK26_BILL_VAR_E2P,       MEM_E2P1,    ADR_BLOCK26_BILL_VAR_E2P,       LEN_BLOCK26_BILL_VAR_E2P,
  54              No_BLOCK101_BILL1_DATA_E2P,    MEM_E2P1,    ADR_BLOCK101_BILL1_DATA_E2P,    LEN_BLOCK10X_BILLX_DATA_E2
             -P,
  55              No_BLOCK102_BILL2_DATA_E2P,    MEM_E2P1,    ADR_BLOCK102_BILL2_DATA_E2P,    LEN_BLOCK10X_BILLX_DATA_E2
             -P,
  56              No_BLOCK103_BILL3_DATA_E2P,    MEM_E2P1,    ADR_BLOCK103_BILL3_DATA_E2P,    LEN_BLOCK10X_BILLX_DATA_E2
             -P,
  57              No_BLOCK104_BILL4_DATA_E2P,    MEM_E2P1,    ADR_BLOCK104_BILL4_DATA_E2P,    LEN_BLOCK10X_BILLX_DATA_E2
             -P,
  58              No_BLOCK105_BILL5_DATA_E2P,    MEM_E2P1,    ADR_BLOCK105_BILL5_DATA_E2P,    LEN_BLOCK10X_BILLX_DATA_E2
             -P,
  59              No_BLOCK106_BILL6_DATA_E2P,    MEM_E2P1,    ADR_BLOCK106_BILL6_DATA_E2P,    LEN_BLOCK10X_BILLX_DATA_E2
             -P,
  60          //    No_BLOCK107_BILL7_DATA_E2P,    MEM_E2P1,    ADR_BLOCK107_BILL7_DATA_E2P,    LEN_BLOCK10X_BILLX_DATA_
             -E2P,
  61          //    No_BLOCK108_BILL8_DATA_E2P,    MEM_E2P1,    ADR_BLOCK108_BILL8_DATA_E2P,    LEN_BLOCK10X_BILLX_DATA_
             -E2P,
  62          //    No_BLOCK109_BILL9_DATA_E2P,    MEM_E2P1,    ADR_BLOCK109_BILL9_DATA_E2P,    LEN_BLOCK10X_BILLX_DATA_
             -E2P,
  63          //    No_BLOCK110_BILL10_DATA_E2P,    MEM_E2P1,    ADR_BLOCK110_BILL10_DATA_E2P,    LEN_BLOCK10X_BILLX_DAT
             -A_E2P,
  64          //    No_BLOCK111_BILL11_DATA_E2P,    MEM_E2P1,    ADR_BLOCK111_BILL11_DATA_E2P,    LEN_BLOCK10X_BILLX_DAT
             -A_E2P,
  65          //    No_BLOCK112_BILL12_DATA_E2P,    MEM_E2P1,    ADR_BLOCK112_BILL12_DATA_E2P,    LEN_BLOCK10X_BILLX_DAT
             -A_E2P,
  66          #endif
  67          
  68           
  69          };
  70          //-------------------------------------------------------------------------------//
  71          //  Function:      INT16U get_mem_ck_data( INT16U src, INT8U  lenth, INT8U memType )             
  72          //  Description:   ¼ÆËãËù¸øµØÖ·¿ªÊ¼µÄ³¤¶ÈÎªLENTHµÄÀÛ¼ÓÐ£ÑéºÍ
  73          //  Parameters:     
  74          //  Returns:                                  
  75          //  Others:  
  76          //-------------------------------------------------------------------------------//
  77          INT16U get_mem_ck_data( INT16U src, INT16U  lenth, INT8U memType )
  78          {
  79   1       INT8U size;
  80   1       INT8U tmpBuf[E2P_PAGE];
  81   1       INT16U   sum = CHECKWORD;
  82   1      
  83   1          while( lenth > 0 )
  84   1          {
  85   2              if( lenth >= E2P_PAGE) 
  86   2              {
  87   3                  size = E2P_PAGE;
  88   3              }
  89   2              else
  90   2              {
  91   3                  size = lenth;
  92   3              }
  93   2              mem_read(&tmpBuf[0], src, size, memType);
  94   2              sum +=Lib_get_csck_int16u_num((INT8U*)&tmpBuf[0], size ,0x0000) ;
  95   2              src += size;
  96   2              lenth -= size;
  97   2         }
  98   1          
  99   1          return sum ;
 100   1      }
 101          
C51 COMPILER V9.01   PROC_EXMEM                                                            03/12/2019 09:56:05 PAGE 3   

 102          
 103          /**********************************************************************
 104                  Get Check Table Point
 105          //ÉÏ²ãµ÷ÓÃµÄ²Ù×÷ÀàÐÍºÍËù¶ÔÓ¦µÄ´æ´¢µÄµØÖ·Ò»ÖÂ
 106            RAM¾Í²éÕÒRAMµÄµØÖ·£¬E2¾Í²éÕÒE2µÄµØÖ·£¬µÈµÈ¡£
 107            µØÖ·Êý¾ÝÀàÐÍÎªint ÐÍ  
 108          **********************************************************************/
 109          INT8U get_mem_table_Index( INT16U adr, INT8U memType )   
 110          {
 111   1       INT8U  i;
 112   1       INT8U  len;
 113   1       INT16U blkAddr; 
 114   1              
 115   1          for( i=0; i<(sizeof(mem_table)/sizeof(E2P_CHECK_TAB)); i++ ) 
 116   1          {
 117   2              if(memType == mem_table[i].mem_type)
 118   2              {
 119   3                  if(memType != MEM_E2P1)
 120   3                  {
 121   4                      return 0xff;
 122   4                  }
 123   3                  else
 124   3                  {
 125   4                      blkAddr =mem_table[i].u16_adr;
 126   4                  }
 127   3                  len = mem_table[i].u16_len;
 128   3      
 129   3                  if( (adr>=blkAddr) && (adr<(blkAddr+len)) )
 130   3                  {
 131   4                      return i;
 132   4                  }
 133   3              }
 134   2          }
 135   1          return 0xff;
 136   1      }
 137          
 138          
 139          /**********************************************************************
 140                  Move Data from Memory to Memory
 141          **********************************************************************/
 142          void mem_to_mem( INT16U dst, INT16U src, INT16U lenth, INT8U mode )
 143          {
 144   1              INT8U   tmp_Buffer[E2P_PAGE];
 145   1              INT8U           size;
 146   1      
 147   1                        while( lenth > 0 )
 148   1                 {
 149   2                            if( lenth > E2P_PAGE )
 150   2                            {
 151   3                                size = E2P_PAGE;
 152   3                            }
 153   2                            else
 154   2                            {
 155   3                                size = lenth;
 156   3                            }
 157   2                            mem_read(&tmp_Buffer[0], src, size, (mode>>4)&0x0F );
 158   2                              CLRWDT();
 159   2                            mem_write( dst, &tmp_Buffer[0], size, mode&0x0F  );
 160   2                            dst += size;
 161   2                            src += size;
 162   2                            lenth -= size;
 163   2                 }
C51 COMPILER V9.01   PROC_EXMEM                                                            03/12/2019 09:56:05 PAGE 4   

 164   1      
 165   1      }
 166          
 167          
 168          /**********************************************************************
 169                  Fill Data to Memory(Flash, InfoFlash, FRAM, EEPROM, DataFlash)
 170          **********************************************************************/
 171          void mem_fill( INT16U dst, INT16U lenth, INT8U xx, INT8U memType )
 172          {
 173   1      INT8U   tmp_Buffer[E2P_PAGE];
 174   1      INT8U size;
 175   1      
 176   1          Lib_Set_String(&tmp_Buffer[0], xx, E2P_PAGE);
 177   1      
 178   1                 while( lenth > 0 )
 179   1                 {
 180   2                            if( lenth > E2P_PAGE )
 181   2                            {
 182   3                                size = E2P_PAGE;
 183   3                            }
 184   2                            else
 185   2                            {
 186   3                                size = lenth;
 187   3                            }
 188   2                            mem_write( dst, &tmp_Buffer[0], size, memType );
 189   2                              CLRWDT();
 190   2                            dst += size;
 191   2                            lenth -= size;
 192   2                 }
 193   1      }
 194          
 195          /**********************************************************************
 196                  Read Data to Memory(FRAM, EEPROM, DataFlash)
 197          **********************************************************************/
 198          void mem_read( INT8U* dst,  INT16U src, INT16U lenth, INT8U memType )
 199          {
 200   1           INT8U  *ptr_adr;
 201   1               
 202   1          switch( memType )
 203   1          {
 204   2              case MEM_RAM:
 205   2                  ptr_adr = &((INT8U *)src);
*** WARNING C182 IN LINE 205 OF ..\C_SOURCE\S0_SYSTEM\PROC_EXMEM.C: pointer to different objects
 206   2                  Lib_Copy_Str_TwoArry( dst, ptr_adr, lenth );
 207   2                //  Lib_FCpyTMem(dst, ptr_adr, lenth);
 208   2              break;
 209   2      
 210   2              case MEM_E2P1:
 211   2                  Read_EEPROM(dst,src, lenth);   //E2P_Read( Dest, Src, Lenth );
 212   2              break;
 213   2      
 214   2              default:
 215   2                  sys_err();
 216   2              break;
 217   2          }
 218   1      }
 219          
 220          /**********************************************************************
 221                  Write Data to Memory( FRAM, EEPROM, DataFlash )
 222          **********************************************************************/
 223          void mem_write( INT16U dst,  INT8U *src, INT16U lenth, INT8U memType )
 224          {
C51 COMPILER V9.01   PROC_EXMEM                                                            03/12/2019 09:56:05 PAGE 5   

 225   1      INT8U  *ptr_adr;
 226   1      
 227   1          switch( memType )
 228   1          {
 229   2              case MEM_RAM:
 230   2                  ptr_adr = &((INT8U *)dst);
*** WARNING C182 IN LINE 230 OF ..\C_SOURCE\S0_SYSTEM\PROC_EXMEM.C: pointer to different objects
 231   2                  Lib_Copy_Str_TwoArry( ptr_adr, src, lenth ); //memcpy( (char*)Dest, Src, Lenth );
 232   2              break;
 233   2      
 234   2              case MEM_E2P1:
 235   2                  Write_EEPROM(dst,src, lenth);                              //E2P_Write( Dest, Src, Lenth );
 236   2              break;
 237   2      
 238   2              default:
 239   2                  sys_err();
 240   2      
 241   2              break;
 242   2          }
 243   1      }
 244          
 245          
 246          
 247          /*
 248          //-------------------------------------------------------------------------------//
 249          //  Function:      void MemWrite( unsigned int dst,  char *src, int lenth, char memType )               
 250          //  Description:  ½«Ö¸¶¨µÄRAMÇø srcµØÖ·ÆðÊ¼µÄÊý¾ÝÐ´ÈëÓÃmemTypeÖ¸¶¨µÄÀàÐÍÆ÷¼þÊý¾ÝÇø
 251          //  Parameters:  char *dst : Ä¿±êÊý¾ÝÇøÊ×µØÖ·
 252          //                     unsigned int src: Ô´Êý¾ÝÇøÊ×µØÖ·£¬RAMÇø
 253          //                     int lenth  :  Êý¾Ý²Ù×÷³¤¶È
 254          //                     char memType  : ´æ´¢Æ÷²Ù×÷ÀàÐÍ
 255          //  Returns:       ÎÞ                            
 256          //  Others:        
 257          //-------------------------------------------------------------------------------//
 258          */
 259          void mem_db_write( INT16U dst,  INT8U *src, INT16U len, INT8U memType )
 260          {
 261   1      INT8U index;
 262   1      ST_U16_U08 checkNum;
 263   1      INT16U adr_dst;
 264   1      INT16U adr_csck;
 265   1      INT16U lenth;
 266   1      INT8U id_No;
 267   1      
 268   1          //»ñÈ¡Êý¾ÝË÷ÒýºÅ//
 269   1          index = get_mem_table_Index(dst, memType );
 270   1              
 271   1          if(index >= (sizeof(mem_table)/sizeof(E2P_CHECK_TAB)))
 272   1          {
 273   2              sys_err();
 274   2          }
 275   1          adr_dst = mem_table[index].u16_adr ;
 276   1          lenth = mem_table[index].u16_len-2;
 277   1          adr_csck =  adr_dst + lenth;  
 278   1          id_No = mem_table[index].u8_No;
 279   1      
 280   1          mem_write(dst, src, len, memType);
 281   1          checkNum.u16 = get_mem_ck_data(adr_dst, lenth, MEM_E2P1);
 282   1          mem_write(adr_csck, &checkNum.B08[0], 2, MEM_E2P1);
 283   1          if(id_No<100) 
 284   1          {  
 285   2              mem_write(dst+E2PBAK_SIZE, src, len, memType);
C51 COMPILER V9.01   PROC_EXMEM                                                            03/12/2019 09:56:05 PAGE 6   

 286   2              mem_write(adr_csck+E2PBAK_SIZE, &checkNum.B08[0], 2, MEM_E2P1);
 287   2          }
 288   1      
 289   1      }
 290          
 291          
 292          /****************************************************************
 293          Function:               void SysInitialize(void)  
 294          Description:            ÏµÍ³ÉÏµç/¸´Î»³õÊ¼»¯º¯Êý 
 295          Input:                  no
 296          Parameters:             no
 297          Returns:                        no                        
 298          Others:         
 299          ****************************************************************/
 300          void get_default_mem_data(uint8 index)
 301          {
 302   1       uint16 adrAry;
 303   1       uint16 lenth;
 304   1       uint8 i;
 305   1      
 306   1          for(i=0;i<(sizeof(mem_table)/sizeof(E2P_CHECK_TAB));i++ )
 307   1          {
 308   2              if(index == mem_table[i].u8_No)   break;
 309   2          }
 310   1       
 311   1          if(i>=(sizeof(mem_table)/sizeof(E2P_CHECK_TAB)))   return;
 312   1      
 313   1              
 314   1          adrAry= mem_table[i].u16_adr;
 315   1          lenth = mem_table[i].u16_len-2;
 316   1          
 317   1          switch(index)
 318   1          {
 319   2              case No_BLOCK20_METER_PARAM1_E2P:
 320   2                  mem_write(adrAry, (INT8U*)&default_meter_parm1_tab, lenth,  MEM_E2P1);
 321   2              break;          
 322   2      
 323   2              case No_BLOCK21_DIS_PARAM_E2P:
 324   2                  mem_write(adrAry, (INT8U*)&default_dis_param_tab, lenth,  MEM_E2P1);
 325   2              break;  
 326   2      
 327   2      
 328   2              case No_BLOCK70_EMU_PARAM_E2P:
 329   2                  mem_write(adrAry, (INT8U*)&default_adj_emu_param_tab, lenth,  MEM_E2P1);
 330   2              break;
 331   2      #if (TARIFF_MAX_NUM>1)
 332   2      #if(MAX_NUM_HOLIDAY_TAB>0)  
                      case No_BLOCK81_HILIDAY_TAB_E2P:
                          mem_write(adrAry, (INT8U*)&default_triff_holiday_tab, lenth,  MEM_E2P1);//block-81 ½Ú¼ÙÈÕ±íÊý¾
             -Ý¿é   //
                      break;
              #endif
 337   2              case No_BLOCK82_SEASON_TAB_E2P:
 338   2                  mem_write(adrAry, (INT8U*)&default_triff_season_tab, lenth,  MEM_E2P1); //block-82 ¼¾½Ú±íÊý¾Ý¿
             -é   //
 339   2              break;
 340   2      
 341   2              case No_BLOCK83_WEEK_TAB_E2P:
 342   2                  mem_write(adrAry, (INT8U*)&default_triff_week_tab, lenth,  MEM_E2P1);//block-83 ÖÜ±íÊý¾Ý¿é   /
             -/
 343   2              break;
 344   2      
C51 COMPILER V9.01   PROC_EXMEM                                                            03/12/2019 09:56:05 PAGE 7   

 345   2              case No_BLOCK84_DAY_TAB_E2P:
 346   2                  mem_write(adrAry, (INT8U*)&default_triff_day_tab, lenth,  MEM_E2P1);//block-84 ÈÕÊ±¶Î±íÊý¾Ý¿é 
             -  //
 347   2              break;
 348   2      #endif
 349   2            /* case No_BLOCK27_EVENII_data:
 350   2                  mem_write(adrAry, (INT8U*)&gs_even_var, lenth,  MEM_E2P1);//block-84 ÈÕÊ±¶Î±íÊý¾Ý¿é   //
 351   2              break;
 352   2              */
 353   2              default:
 354   2                  mem_fill(adrAry, lenth, 0x00, MEM_E2P1);
 355   2              break;
 356   2          }
 357   1      }
 358          
 359          
 360          /*
 361          //-------------------------------------------------------------------------------//
 362          //  Function:      void MemWrite( unsigned int dst,  char *src, int lenth, char memType )               
 363          //  Description:  ½«Ö¸¶¨µÄRAMÇø srcµØÖ·ÆðÊ¼µÄÊý¾ÝÐ´ÈëÓÃmemTypeÖ¸¶¨µÄÀàÐÍÆ÷¼þÊý¾ÝÇø
 364          //  Parameters:  char *dst : Ä¿±êÊý¾ÝÇøÊ×µØÖ·
 365          //                     unsigned int src: Ô´Êý¾ÝÇøÊ×µØÖ·£¬RAMÇø
 366          //                     int lenth  :  Êý¾Ý²Ù×÷³¤¶È
 367          //                     char memType  : ´æ´¢Æ÷²Ù×÷ÀàÐÍ
 368          //  Returns:       ÎÞ                            
 369          //  Others:        
 370          //-------------------------------------------------------------------------------//
 371          */
 372          void mem_db_check( void )
 373          {
 374   1       INT8U i;
 375   1       ST_U16_U08 checkNum0;
 376   1       ST_U16_U08 checkNum1;
 377   1       INT16U adr_dst;
 378   1       INT16U adr_csck;
 379   1       INT16U lenth;
 380   1       INT8U staus;
 381   1       uint8  u8_No;
 382   1      
 383   1          for(i=0;i<(sizeof(mem_table)/sizeof(E2P_CHECK_TAB));i++ )
 384   1          {
 385   2              staus = 0;
 386   2              adr_dst= mem_table[i].u16_adr;
 387   2              lenth = mem_table[i].u16_len-2;
 388   2              adr_csck = adr_dst + lenth; 
 389   2              u8_No = mem_table[i].u8_No;
 390   2      
 391   2              CLRWDT();
 392   2              //check main aera data  //
 393   2              checkNum0.u16= get_mem_ck_data(adr_dst,lenth, MEM_E2P1);
 394   2              mem_read(&checkNum1.B08[0], adr_csck, 2,MEM_E2P1 );
 395   2              if(checkNum0.u16 != checkNum1.u16)  staus |= 0x01;
 396   2         
 397   2              if(u8_No<100)     
 398   2              {
 399   3                  //check backup aera data  //
 400   3                  checkNum0.u16 = get_mem_ck_data(adr_dst+E2PBAK_SIZE,lenth, MEM_E2P1);
 401   3                  mem_read(&checkNum1.B08[0], adr_csck+E2PBAK_SIZE, 2,MEM_E2P1 );
 402   3                  if(checkNum0.u16 != checkNum1.u16)  staus |= 0x02;
 403   3              }
 404   2                  
 405   2              // deal to checked  result  //
C51 COMPILER V9.01   PROC_EXMEM                                                            03/12/2019 09:56:05 PAGE 8   

 406   2      //DEBUGE  //
 407   2      //staus=0X03;
 408   2      ////////
 409   2              CLRWDT();
 410   2              switch(staus)
 411   2              {
 412   3                  case 0:                // main aera data right, backup aera data right //
 413   3      
 414   3                      break;
 415   3      
 416   3                  case 1:               // main aera data error, backup aera data right //
 417   3                       if(u8_No<100)
 418   3                      {     
 419   4                         mem_to_mem(adr_dst, adr_dst+E2PBAK_SIZE, lenth+2, (MEM_E2P1<<4)+MEM_E2P1);
 420   4                      }
 421   3                      else
 422   3                      {
 423   4                          get_default_mem_data(u8_No);   
 424   4                          checkNum0.u16= get_mem_ck_data(adr_dst,lenth, MEM_E2P1);
 425   4                          mem_write(adr_csck, &checkNum0.B08[0], 2, MEM_E2P1);
 426   4                      }
 427   3                      CLRWDT();
 428   3                      break;  
 429   3      
 430   3                  case 2:              // main aera data right, backup aera data error //
 431   3                          if(u8_No<100)     
 432   3                                  {
 433   4                           mem_to_mem(adr_dst+E2PBAK_SIZE,adr_dst, lenth+2, (MEM_E2P1<<4)+MEM_E2P1);
 434   4                                   CLRWDT();
 435   4                                      }
 436   3                                      //      mem_read(&checkNum1.B08[0], adr_csck+E2PBAK_SIZE, 2,MEM_E2P1 );
 437   3                      break;  
 438   3      
 439   3                  case 3:               // main aera data error, backup aera data error //
 440   3                              get_default_mem_data(u8_No);
 441   3                              checkNum0.u16= get_mem_ck_data(adr_dst,lenth, MEM_E2P1);
 442   3                              mem_write(adr_csck, &checkNum0.B08[0], 2, MEM_E2P1);
 443   3                              CLRWDT();
 444   3                  if(u8_No<100)     
 445   3                              {
 446   4                              mem_to_mem(adr_dst+E2PBAK_SIZE,adr_dst, lenth+2, (MEM_E2P1<<4)+MEM_E2P1); 
 447   4                              CLRWDT();
 448   4                  }
 449   3                  break;                   
 450   3      
 451   3                  default:               
 452   3                         sys_err();
 453   3                      break;                     
 454   3              }
 455   2              CLRWDT();
 456   2              
 457   2          }
 458   1      
 459   1      }
 460          
 461          
 462          
 463          /*
 464          //-------------------------------------------------------------------------------//
 465          //  Function:      mem_db_clr           
 466          //  Description:  ½«ËùÓÐµÄ±¸·ÝÊý¾Ý±¸·ÝÇøÇåÁã£¬ÓÃÓÚ³õÊ¼»¯E2PÊý¾Ý
 467          //  Parameters:  char *dst : Ä¿±êÊý¾ÝÇøÊ×µØÖ·
C51 COMPILER V9.01   PROC_EXMEM                                                            03/12/2019 09:56:05 PAGE 9   

 468          //                     unsigned int src: Ô´Êý¾ÝÇøÊ×µØÖ·£¬RAMÇø
 469          //                     int lenth  :  Êý¾Ý²Ù×÷³¤¶È
 470          //                     char memType  : ´æ´¢Æ÷²Ù×÷ÀàÐÍ
 471          //  Returns:       ÎÞ                            
 472          //  Others:        
 473          //-------------------------------------------------------------------------------//
 474          */
 475          void mem_db_clr( uint8 type )
 476          {
 477   1       INT8U i;
 478   1       ST_U16_U08 checkNum0;
 479   1       INT16U adr_dst;
 480   1       INT16U adr_csck;
 481   1       INT8U lenth;
 482   1       uint8  u8_No;
 483   1      
 484   1          for(i=0;i<(sizeof(mem_table)/sizeof(E2P_CHECK_TAB));i++ )
 485   1          {
 486   2              adr_dst= mem_table[i].u16_adr;
 487   2              lenth = mem_table[i].u16_len-2;
 488   2              adr_csck = adr_dst + lenth; 
 489   2              u8_No = mem_table[i].u8_No;
 490   2      
 491   2               if((u8_No !=No_BLOCK70_EMU_PARAM_E2P) ||(type ==0XA5))
 492   2                {
 493   3                   CLRWDT();
 494   3                  //check main aera data  //
 495   3                  checkNum0.u16= 0;
 496   3                  mem_write(adr_csck,&checkNum0.B08[0],  2,MEM_E2P1 );
 497   3             
 498   3                  if(u8_No<100)     
 499   3                  {
 500   4                      //check backup aera data  //
 501   4                      checkNum0.u16 = 0;
 502   4                      mem_write(adr_csck+E2PBAK_SIZE,&checkNum0.B08[0],  2,MEM_E2P1 );
 503   4                  }
 504   3              }
 505   2                  
 506   2          }
 507   1      
 508   1      }
 509          
 510          /***************************************************************
 511          *    END
 512          ****************************************************************/
 513          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2265    ----
   CONSTANT SIZE    =    108    ----
   XDATA SIZE       =   ----     280
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
